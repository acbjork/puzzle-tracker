<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üß† I'm Puzzled ‚ÄºÔ∏è</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: system-ui, sans-serif; margin: 1em; }
    h1, .subtitle { text-align: center; margin: 0; }
    .subtitle { font-size: 0.95em; color: #555; margin-top: 0.2em; margin-bottom: 2em; }
    .user-select-area { margin-top: 1em; margin-bottom: 3em; }
    table { width: 100%; border-collapse: collapse; margin-top: 1em; }
    th, td { border: 1px solid #ccc; padding: 0.5em; vertical-align: top; text-align: center; }
    th:first-child, td:first-child { text-align: left; }
    textarea { width: 95%; box-sizing: border-box; }
    .submitted { white-space: pre-wrap; background: transparent; padding: 0.25em 0.5em; line-height: 1.2; border-radius: 4px; }
    .winner { background-color: #d6f5d6 !important; }
    .tie { background-color: #fff9c4 !important; }
    .version { text-align: right; font-size: 0.85em; color: #888; margin-top: 2em; }
    
    #scoreboard { margin: 1em 0; display: flex; justify-content: space-around; font-family: monospace; font-size: 1.5em; position: relative; }
    .scoreboard-label { font-weight: bold; text-align: center; position: relative; }
    .scoreboard-value { display: block; font-size: 1.5em; }
    .crown { position: absolute; top: -40px; left: 50%; transform: translateX(-50%); font-size: 2em; animation: crownBounce 1s ease-in-out infinite alternate; }
    @keyframes crownBounce { 0% { transform: translateX(-50%) translateY(0px); } 100% { transform: translateX(-50%) translateY(-5px); } }

    #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; color: #444; font-size: 1.5em; display: flex; align-items: center; justify-content: center; z-index: 9999; }

    .chat-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1000; display: none; backdrop-filter: blur(4px); }
    .chat-window { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 500px; height: 80%; max-height: 600px; background: white; border-radius: 12px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; overflow: hidden; }
    .chat-header { background: linear-gradient(135deg, #cc5500, #4a4a4a); color: white; padding: 1em; font-weight: bold; font-size: 1.1em; text-align: center; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); position: relative; }
    .chat-close-btn { position: absolute; top: 50%; right: 1em; transform: translateY(-50%); background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; }
    .chat-close-btn:hover { background: rgba(255, 255, 255, 0.2); }
    .chat-messages { flex: 1; overflow-y: auto; padding: 1em; background: #f9f9f9; -webkit-overflow-scrolling: touch; }
    .chat-message { margin-bottom: 1em; display: flex; align-items: flex-start; animation: messageSlide 0.3s ease-out; position: relative; }
    @keyframes messageSlide { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    .chat-message.current-user { justify-content: flex-end; }
    .chat-message.other-user { justify-content: flex-start; }
    .message-bubble { max-width: 75%; padding: 0.75em 1em; border-radius: 18px; word-wrap: break-word; position: relative; cursor: pointer; transition: transform 0.1s; }
    .message-bubble:hover { transform: scale(1.02); }
    .message-bubble.current-user { background: #cc5500; color: white; border-bottom-right-radius: 4px; }
    .message-bubble.other-user { background: #e5e5e5; color: black; border-bottom-left-radius: 4px; }
    .message-bubble.deleted { background: #f0f0f0 !important; color: #888 !important; font-style: italic; opacity: 0.7; cursor: default; }
    .message-bubble.deleted:hover { transform: none; }
    .sender { font-weight: bold; font-size: 0.8em; margin-bottom: 0.25em; opacity: 0.8; }
    .message-text { font-size: 0.9em; line-height: 1.3; }
    .timestamp { font-size: 0.7em; opacity: 0.7; margin-top: 0.25em; }
    .chat-input-area { padding: 1em; background: white; border-top: 1px solid #ddd; display: flex; gap: 0.5em; align-items: flex-end; }
    .chat-input { flex: 1; padding: 0.75em; border: 2px solid #ddd; border-radius: 20px; font-size: 0.9em; resize: none; min-height: 40px; max-height: 80px; outline: none; transition: border-color 0.2s; }
    .chat-input:focus { border-color: #4ecdc4; }
    .chat-send-btn { background: linear-gradient(135deg, #666, #333); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 1.2em; transition: transform 0.2s, box-shadow 0.2s; display: flex; align-items: center; justify-content: center; }
    .chat-send-btn:hover { transform: scale(1.05); box-shadow: 0 4px 12px rgba(102, 102, 102, 0.4); }
    .chat-send-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    .chat-empty { text-align: center; color: #888; font-style: italic; padding: 2em; }
    .unread-indicator { position: absolute; top: -5px; right: -5px; background: #ff4757; color: white; border-radius: 50%; width: 20px; height: 20px; font-size: 0.7em; display: flex; align-items: center; justify-content: center; font-weight: bold; animation: pulse 2s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    .chat-toggle { position: relative; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 0.75em 1.5em; border-radius: 25px; cursor: pointer; font-weight: bold; margin: 1em 0; transition: all 0.3s; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
    .chat-toggle:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
    /* Button container for chat + history */
.button-container { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  margin: 1em 0; 
}
.button-container > div { flex: 1; }
.button-container > div:first-child { text-align: left; }
.button-container > div:last-child { text-align: right; }

/* History modal and styling */
.history-modal { 
  position: fixed; 
  top: 0; 
  left: 0; 
  width: 100%; 
  height: 100%; 
  background: rgba(0, 0, 0, 0.5); 
  z-index: 1000; 
  display: none; 
  backdrop-filter: blur(4px); 
}
.history-window { 
  position: absolute; 
  top: 50%; 
  left: 50%; 
  transform: translate(-50%, -50%); 
  width: 90%; 
  max-width: 500px; 
  height: 80%; 
  max-height: 600px; 
  background: white; 
  border-radius: 12px; 
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); 
  display: flex; 
  flex-direction: column; 
  overflow: hidden; 
}
.history-header { 
  background: linear-gradient(135deg, #6b46c1, #8b5cf6); 
  color: white; 
  padding: 1em; 
  font-weight: bold; 
  font-size: 1.1em; 
  text-align: center; 
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3); 
  position: relative; 
}
.history-close-btn { 
  position: absolute; 
  top: 50%; 
  right: 1em; 
  transform: translateY(-50%); 
  background: none; 
  border: none; 
  color: white; 
  font-size: 1.5em; 
  cursor: pointer; 
  width: 30px; 
  height: 30px; 
  border-radius: 50%; 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  transition: background-color 0.2s; 
}
.history-close-btn:hover { background: rgba(255, 255, 255, 0.2); }
.history-content { 
  flex: 1; 
  overflow-y: auto; 
  padding: 1.5em; 
  background: #f9f9f9; 
  -webkit-overflow-scrolling: touch; 
}
.history-toggle { 
  position: relative; 
  background: linear-gradient(135deg, #6b46c1, #8b5cf6); 
  color: white; 
  border: none; 
  padding: 0.75em 1.5em; 
  border-radius: 25px; 
  cursor: pointer; 
  font-weight: bold; 
  margin: 1em 0; 
  transition: all 0.3s; 
  box-shadow: 0 4px 15px rgba(107, 70, 193, 0.3); 
}
.history-toggle:hover { 
  transform: translateY(-2px); 
  box-shadow: 0 6px 20px rgba(107, 70, 193, 0.4); 
}

/* History content styling */
.overall-winner { 
  background: linear-gradient(135deg, #ffd700, #ffed4e); 
  padding: 1.5em; 
  border-radius: 12px; 
  margin-bottom: 1.5em; 
  text-align: center; 
  box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3); 
}
.overall-winner h3 { 
  margin: 0 0 0.5em 0; 
  font-size: 1.3em; 
  color: #b8860b; 
}
.overall-winner .winner-name { 
  font-size: 1.8em; 
  font-weight: bold; 
  color: #8b4513; 
  margin: 0.25em 0; 
}
.overall-winner .streak { 
  font-size: 1.2em; 
  color: #8b4513; 
  margin: 0.25em 0; 
}
.puzzle-winners { 
  background: white; 
  border-radius: 8px; 
  padding: 1em; 
}
.puzzle-winners h4 { 
  margin: 0 0 1em 0; 
  color: #666; 
  font-size: 1em; 
  text-align: center; 
}
.puzzle-winner-item { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  padding: 0.5em 0; 
  border-bottom: 1px solid #eee; 
}
.puzzle-winner-item:last-child { border-bottom: none; }
.puzzle-name { font-weight: bold; color: #333; }
.puzzle-streak { color: #666; font-size: 0.9em; }

/* Mobile responsive updates */
@media (max-width: 768px) {
  .button-container { 
    flex-direction: column; 
    gap: 0.5em; 
  }
  .button-container > div { text-align: center; }
  .history-window { width: 98%; height: 95%; max-width: none; }
  .history-content { padding: 0.75em; }
}

@media (max-width: 480px) {
  .history-window { 
    width: 100%; 
    height: 100%; 
    border-radius: 0; 
    top: 0; 
    left: 0; 
    transform: none; 
  }
}
    .delete-confirmation { position: absolute; top: -40px; right: 0; background: #ff4757; color: white; padding: 0.5em; border-radius: 8px; font-size: 0.8em; white-space: nowrap; z-index: 10; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); }
    .delete-confirmation button { background: white; color: #ff4757; border: none; padding: 0.25em 0.5em; margin: 0 0.25em; border-radius: 4px; cursor: pointer; font-size: 0.8em; }

    @media (max-width: 768px) {
      body { margin: 0.5em; }
      table { font-size: 0.8em; }
      th:first-child, td:first-child { width: 25%; max-width: 80px; word-wrap: break-word; line-height: 1.2; }
      th:nth-child(2), th:nth-child(3), td:nth-child(2), td:nth-child(3) { width: 37.5%; }
      .submitted { font-size: 0.85em; line-height: 1.1; padding: 0.2em 0.4em; }
      #scoreboard { font-size: 1.2em; flex-wrap: wrap; gap: 0.5em; }
      .chat-window { width: 98%; height: 95%; max-width: none; }
      .chat-messages { padding: 0.75em; }
      .message-bubble { max-width: 85%; padding: 0.6em 0.8em; }
      textarea { width: 92%; }
    }

    @media (max-width: 480px) {
      h1 { font-size: 1.5em; }
      .subtitle { font-size: 0.85em; }
      th:first-child, td:first-child { width: 20%; max-width: 60px; font-size: 0.75em; }
      .submitted { font-size: 0.75em; }
      #scoreboard { font-size: 1em; }
      .scoreboard-value { font-size: 1.2em; }
      .chat-window { width: 100%; height: 100%; border-radius: 0; top: 0; left: 0; transform: none; }
    }
  </style>
</head>
<body>
  <div id="loadingOverlay">Loading‚Ä¶</div>
  <h1>üß† I'm Puzzled ‚ÄºÔ∏è</h1>
  <div class="subtitle">If you ain't first, you're last</div>

  <div class="user-select-area">
    <label for="userSelect">Signed in as:
      <select id="userSelect">
        <option value="">(choose)</option>
        <option value="Adam">Adam üåµ</option>
        <option value="Jonathan">Jonathan üí©</option>
      </select>
    </label>
  </div>

  <div id="scoreboard">
    <div class="scoreboard-label">ACB
      <span id="acbCrown" class="crown" style="display: none;">üëë</span>
      <span id="acbCount" class="scoreboard-value">0</span>
    </div>
    <div class="scoreboard-label">JBB
      <span id="jbbCrown" class="crown" style="display: none;">üëë</span>
      <span id="jbbCount" class="scoreboard-value">0</span>
    </div>
    <div class="scoreboard-label">Tie<span id="tieCount" class="scoreboard-value">0</span></div>
    <div class="scoreboard-label">Remaining<span id="remainingCount" class="scoreboard-value">10</span></div>
  </div>

  <button id="chatToggle" class="chat-toggle" style="display: none;">
    üí¨ Trash Talk Central üóëÔ∏è
    <span id="unreadBadge" class="unread-indicator" style="display: none;">0</span>
  </button>

  <div class="chat-modal" id="chatModal">
    <div class="chat-window">
      <div class="chat-header">
        üí¨ Trash Talk Central üóëÔ∏è
        <button class="chat-close-btn" id="chatCloseBtn">‚úï</button>
      </div>
      <div class="chat-messages" id="chatMessages">
        <div class="chat-empty">No trash talk yet... someone needs to start the smack down! üî•</div>
      </div>
      <div class="chat-input-area">
        <textarea id="chatInput" class="chat-input" placeholder="Drop some trash talk... üî•" maxlength="500" disabled></textarea>
        <button id="chatSendBtn" class="chat-send-btn" disabled>üöÆ</button>
      </div>
    </div>
  </div>

  <table id="puzzleTable">
    <thead>
      <tr><th>Puzzle</th><th>Adam üåµ</th><th>Jonathan üí©</th></tr>
    </thead>
    <tbody id="puzzleRows">
      <tr data-puzzle="Connections"><td>Connections</td><td data-cell="Connections-Adam"></td><td data-cell="Connections-Jonathan"></td></tr>
      <tr data-puzzle="Strands"><td>Strands</td><td data-cell="Strands-Adam"></td><td data-cell="Strands-Jonathan"></td></tr>
      <tr data-puzzle="On The Record"><td>On The Record</td><td data-cell="On The Record-Adam"></td><td data-cell="On The Record-Jonathan"></td></tr>
      <tr data-puzzle="Keyword"><td>Keyword</td><td data-cell="Keyword-Adam"></td><td data-cell="Keyword-Jonathan"></td></tr>
      <tr data-puzzle="NYT Mini"><td>NYT Mini</td><td data-cell="NYT Mini-Adam"></td><td data-cell="NYT Mini-Jonathan"></td></tr>
      <tr data-puzzle="Apple Mini"><td>Apple Mini</td><td data-cell="Apple Mini-Adam"></td><td data-cell="Apple Mini-Jonathan"></td></tr>
      <tr data-puzzle="Globle"><td>Globle</td><td data-cell="Globle-Adam"></td><td data-cell="Globle-Jonathan"></td></tr>
      <tr data-puzzle="Flagle"><td>Flagle</td><td data-cell="Flagle-Adam"></td><td data-cell="Flagle-Jonathan"></td></tr>
      <tr data-puzzle="Wordle"><td>Wordle</td><td data-cell="Wordle-Adam"></td><td data-cell="Wordle-Jonathan"></td></tr>
      <tr data-puzzle="Tightrope"><td>Tightrope</td><td data-cell="Tightrope-Adam"></td><td data-cell="Tightrope-Jonathan"></td></tr>
    </tbody>
  </table>

  <div class="version">v0.6.0 - History and chat sync! üìöüí¨</div>

  <!-- Load Supabase library globally -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>

    const supabase = supabase.createClient("https://iqhgsdpqqshfeiqrkrqw.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlxaGdzZHBxcXNoZmVpcXJrcnF3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NjExMDAsImV4cCI6MjA2MzQzNzEwMH0.W3eH88RD9s3pmuVlA-H7VIfVWLq_ymtj22JLd2f9Cec");

    const today = new Date().toISOString().slice(0, 10);
    let currentUser = '';
    try {
      const urlParams = new URLSearchParams(window.location.search);
      const urlUser = urlParams.get('user');
      const storedUser = sessionStorage.getItem('selectedUser');
      currentUser = urlUser || storedUser || "";
    } catch { currentUser = ""; }
    
    const puzzles = ["Connections", "Strands", "On The Record", "Keyword", "NYT Mini", "Apple Mini", "Globle", "Flagle", "Wordle", "Tightrope"];
    const results = {};
    const cellMap = {};
    let chatMessages = [];
    let isChatVisible = false;
    let isHistoryVisible = false;
    let hasUnreadMessages = false;

    const userSelect = document.querySelector("#userSelect");
    if (userSelect) {
      userSelect.value = currentUser;
      userSelect.addEventListener("change", (e) => {
        const newUser = e.target.value;
        if (newUser) {
          sessionStorage.setItem('selectedUser', newUser);
          const url = new URL(window.location);
          url.searchParams.set('user', newUser);
          window.location.href = url.toString();
        }
      });
    }

    function shouldRenderTable() { return currentUser && (currentUser === "Adam" || currentUser === "Jonathan"); }
    
    // Cross-device sync for chat read status
async function loadLastReadFromSupabase() {
  if (!currentUser) return;
  try {
    const { data, error } = await supabase
      .from("user_settings")
      .select("last_read_chat_message_id")
      .eq("user_id", currentUser)
      .single();
    
    if (!error && data) {
      lastReadMessageId = data.last_read_chat_message_id;
    }
  } catch (error) {
    console.error("Failed to load read status:", error);
  }
}

async function saveLastReadToSupabase(messageId) {
  if (!currentUser || !messageId) return;
  try {
    const { error } = await supabase
      .from("user_settings")
      .upsert({
        user_id: currentUser,
        last_read_chat_message_id: messageId,
        updated_at: new Date().toISOString()
      }, {
        onConflict: "user_id"
      });
    
    if (error) {
      console.error("Failed to save read status:", error);
    }
  } catch (error) {
    console.error("Network error saving read status:", error);
  }
}

    async function loadChatMessages() {
      try {
        const { data, error } = await supabase.from("chat_messages").select("*").eq("date", today).order("created_at", { ascending: true });
        if (error) { console.error("Error loading chat messages:", error.message); return; }
        chatMessages = data || [];
        renderChatMessages();
        updateUnreadBadge();
      } catch (error) { console.error("Failed to load chat messages:", error); }
    }

    function renderChatMessages() {
      const container = document.getElementById('chatMessages');
      if (chatMessages.length === 0) {
        container.innerHTML = '<div class="chat-empty">No trash talk yet... someone needs to start the smack down! üî•</div>';
        return;
      }
      container.innerHTML = '';
      chatMessages.forEach(msg => {
        const messageDiv = document.createElement('div');
        const isCurrentUser = msg.player === currentUser;
        messageDiv.className = `chat-message ${isCurrentUser ? 'current-user' : 'other-user'}`;
        const senderEmoji = msg.player === 'Adam' ? 'üåµ' : 'üí©';
        const timestamp = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = `message-bubble ${isCurrentUser ? 'current-user' : 'other-user'}`;
        if (msg.message === '[deleted]') {
          bubbleDiv.classList.add('deleted');
          bubbleDiv.innerHTML = `<div class="sender">${msg.player} ${senderEmoji}</div><div class="message-text">This message was deleted</div><div class="timestamp">${timestamp}</div>`;
        } else {
          bubbleDiv.innerHTML = `<div class="sender">${msg.player} ${senderEmoji}</div><div class="message-text">${escapeHtml(msg.message)}</div><div class="timestamp">${timestamp}</div>`;
          if (isCurrentUser) bubbleDiv.addEventListener('click', () => showDeleteConfirmation(bubbleDiv, msg.id));
        }
        messageDiv.appendChild(bubbleDiv);
        container.appendChild(messageDiv);
      });
      container.scrollTop = container.scrollHeight;
    }

    function showDeleteConfirmation(bubbleElement, messageId) {
      document.querySelectorAll('.delete-confirmation').forEach(el => el.remove());
      const confirmDiv = document.createElement('div');
      confirmDiv.className = 'delete-confirmation';
      confirmDiv.innerHTML = `Delete this message? <button onclick="deleteMessage('${messageId}')">Yes</button> <button onclick="this.parentElement.remove()">No</button>`;
      bubbleElement.style.position = 'relative';
      bubbleElement.appendChild(confirmDiv);
      setTimeout(() => { if (confirmDiv.parentElement) confirmDiv.remove(); }, 5000);
    }

    window.deleteMessage = async function(messageId) {
      try {
        const { error } = await supabase.from("chat_messages").update({ message: '[deleted]' }).eq("id", messageId);
        if (error) {
          console.error("Error deleting message:", error.message);
          alert("Failed to delete message. Try again.");
        } else {
          const msgIndex = chatMessages.findIndex(m => m.id === messageId);
          if (msgIndex !== -1) {
            chatMessages[msgIndex].message = '[deleted]';
            renderChatMessages();
          }
        }
      } catch (error) {
        console.error("Network error deleting message:", error);
        alert("Network error. Try again.");
      }
      document.querySelectorAll('.delete-confirmation').forEach(el => el.remove());
    };

    function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

    async function sendChatMessage() {
      const chatInput = document.getElementById('chatInput');
      const message = chatInput.value.trim();
      if (!message || !currentUser) return;
      const sendBtn = document.getElementById('chatSendBtn');
      sendBtn.disabled = true;
      sendBtn.textContent = '‚è≥';
      try {
        const { error } = await supabase.from("chat_messages").insert({ date: today, player: currentUser, message: message });
        if (error) {
          console.error("Error sending message:", error.message);
          alert("Failed to send message. Try again.");
        } else {
          chatInput.value = '';
        }
      } catch (error) {
        console.error("Network error sending message:", error);
        alert("Network error. Try again.");
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = 'üöÆ';
      }
    }

    function updateUnreadBadge() {
      const unreadBadge = document.getElementById('unreadBadge');
      
      // Always hide badge if chat is open
      if (isChatVisible) {
        unreadBadge.style.display = 'none';
        return;
      }
      
      // Show badge only if we have unread messages and chat is closed
      if (hasUnreadMessages) {
        const unreadCount = chatMessages.filter(msg => 
          msg.player !== currentUser && msg.message !== '[deleted]'
        ).length;
        if (unreadCount > 0) {
          unreadBadge.textContent = unreadCount;
          unreadBadge.style.display = 'flex';
        } else {
          unreadBadge.style.display = 'none';
        }
      } else {
        unreadBadge.style.display = 'none';
      }
    }

    function markChatAsRead() {
  if (chatMessages.length > 0) {
    const otherPlayerMessages = chatMessages.filter(msg => 
      msg.player !== currentUser && msg.message !== '[deleted]'
    );
    if (otherPlayerMessages.length > 0) {
      const latestMessage = otherPlayerMessages[otherPlayerMessages.length - 1];
      lastReadMessageId = latestMessage.id;
      saveLastReadToSupabase(latestMessage.id); // ADD THIS LINE
    }
  }
  updateUnreadBadge();
}

    function setupChatEventListeners() {
      const chatToggle = document.getElementById('chatToggle');
      const chatModal = document.getElementById('chatModal');
      const chatCloseBtn = document.getElementById('chatCloseBtn');
      const chatInput = document.getElementById('chatInput');
      const chatSendBtn = document.getElementById('chatSendBtn');

      chatToggle.addEventListener('click', () => {
        chatModal.style.display = 'block';
        isChatVisible = true;
        document.body.style.overflow = 'hidden';
        
        // Mark all messages as read and hide badge
        hasUnreadMessages = false;
        document.getElementById('unreadBadge').style.display = 'none';
        
        chatInput.focus();
      });

      function closeChat() {
        chatModal.style.display = 'none';
        isChatVisible = false;
        document.body.style.overflow = '';
        updateUnreadBadge();
      }

      chatCloseBtn.addEventListener('click', closeChat);
      chatModal.addEventListener('click', (e) => { if (e.target === chatModal) closeChat(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isChatVisible) closeChat(); });
      chatSendBtn.addEventListener('click', sendChatMessage);
      chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); } });
      chatInput.addEventListener('input', () => {
        const hasText = chatInput.value.trim().length > 0;
        chatSendBtn.disabled = !hasText || !currentUser;
      });
    }

    function showChatInterface() {
  if (shouldRenderTable()) {
    document.getElementById('chatToggle').style.display = 'block';
    document.getElementById('historyToggle').style.display = 'block'; // ADD THIS LINE
    document.getElementById('chatInput').disabled = false;
    document.getElementById('chatSendBtn').disabled = false;
  } else {
    document.getElementById('chatToggle').style.display = 'none';
    document.getElementById('historyToggle').style.display = 'none'; // ADD THIS LINE
    document.getElementById('chatModal').style.display = 'none';
    document.getElementById('historyModal').style.display = 'none'; // ADD THIS LINE
    isChatVisible = false;
    isHistoryVisible = false; // ADD THIS LINE
  }
}
    // History functionality
async function loadHistoryData() {
  try {
    document.getElementById('lastOverallWinner').textContent = 'Loading...';
    document.getElementById('overallStreak').textContent = 'Calculating streak...';
    document.getElementById('puzzleStreaks').innerHTML = 'Loading puzzle streaks...';
    
    const { data: recentResults, error } = await supabase
      .from("results")
      .select("*")
      .gte('date', getDateDaysAgo(30))
      .neq("raw_result", "")
      .order("date", { ascending: false });

    if (error) {
      console.error("Error loading history data:", error.message);
      showHistoryError();
      return;
    }

    calculateAndDisplayHistory(recentResults || []);
  } catch (error) {
    console.error("Failed to load history data:", error);
    showHistoryError();
  }
}

function getDateDaysAgo(days) {
  const date = new Date();
  date.setDate(date.getDate() - days);
  return date.toISOString().slice(0, 10);
}

function showHistoryError() {
  document.getElementById('lastOverallWinner').textContent = 'Error loading data';
  document.getElementById('overallStreak').textContent = 'Please try again later';
  document.getElementById('puzzleStreaks').innerHTML = '<div class="puzzle-winner-item"><span class="puzzle-name">Unable to load</span><span class="puzzle-streak">Check connection</span></div>';
}

function calculateAndDisplayHistory(recentResults) {
  // Group results by date
  const resultsByDate = {};
  recentResults.forEach(result => {
    if (!resultsByDate[result.date]) {
      resultsByDate[result.date] = {};
    }
    if (!resultsByDate[result.date][result.puzzle_name]) {
      resultsByDate[result.date][result.puzzle_name] = {};
    }
    resultsByDate[result.date][result.puzzle_name][result.player] = result.raw_result;
  });

  const dailyWinners = [];
  const sortedDates = Object.keys(resultsByDate).sort().reverse();

  // Calculate daily winners using same logic as main table
  sortedDates.forEach(date => {
    const dayResults = resultsByDate[date];
    let adamWins = 0, jonWins = 0, ties = 0;

    puzzles.forEach(puzzle => {
      if (dayResults[puzzle] && dayResults[puzzle].Adam && dayResults[puzzle].Jonathan) {
        const winner = determineWinnerSimple(puzzle, dayResults[puzzle].Adam, dayResults[puzzle].Jonathan);
        if (winner === 'Adam') adamWins++;
        else if (winner === 'Jonathan') jonWins++;
        else ties++;
      }
    });

    if (adamWins > jonWins) {
      dailyWinners.push({ date, winner: 'Adam üåµ', score: `${adamWins}-${jonWins}` });
    } else if (jonWins > adamWins) {
      dailyWinners.push({ date, winner: 'Jonathan üí©', score: `${jonWins}-${adamWins}` });
    } else if (adamWins + jonWins > 0) {
      dailyWinners.push({ date, winner: 'Tie', score: `${adamWins}-${jonWins}` });
    }
  });

  // Display most recent winner
  const lastWinnerEl = document.getElementById('lastOverallWinner');
  const streakEl = document.getElementById('overallStreak');
  
  if (dailyWinners.length > 0) {
    const lastWinner = dailyWinners[0];
    lastWinnerEl.textContent = lastWinner.winner;
    
    // Calculate streak
    let currentStreak = 1;
    const winnerName = lastWinner.winner;
    
    for (let i = 1; i < dailyWinners.length; i++) {
      if (dailyWinners[i].winner === winnerName) {
        currentStreak++;
      } else {
        break;
      }
    }
    
    if (winnerName === 'Tie') {
      streakEl.textContent = `Tied ${lastWinner.score}`;
    } else {
      streakEl.textContent = `${currentStreak} day${currentStreak > 1 ? 's' : ''} winning streak!`;
    }
  } else {
    lastWinnerEl.textContent = 'No recent data';
    streakEl.textContent = 'Play some games first!';
  }

  // Simple puzzle streaks display
  displaySimplePuzzleStreaks();
}

function determineWinnerSimple(puzzle, adamResult, jonResult) {
  // Simplified winner logic for history - just do basic ones
  if (puzzle === "Wordle") {
    const aScore = parseInt(adamResult.match(/\b(\d)\/6/)?.[1] || "7");
    const jScore = parseInt(jonResult.match(/\b(\d)\/6/)?.[1] || "7");
    if (aScore < jScore) return 'Adam';
    else if (jScore < aScore) return 'Jonathan';
    else return 'tie';
  }
  
  if (puzzle === "Connections") {
    const aLines = adamResult.split("\n");
    const jLines = jonResult.split("\n");
    const aIndex = aLines.findIndex(line => line.includes("üü™üü™üü™üü™"));
    const jIndex = jLines.findIndex(line => line.includes("üü™üü™üü™üü™"));
    if (aIndex !== -1 && (jIndex === -1 || aIndex < jIndex)) return 'Adam';
    else if (jIndex !== -1 && (aIndex === -1 || jIndex < aIndex)) return 'Jonathan';
    else return 'tie';
  }
  
  // For other puzzles, return tie for now
  return 'tie';
}

function displaySimplePuzzleStreaks() {
  const streaksContainer = document.getElementById('puzzleStreaks');
  let html = '';
  
  // Simple display for now
  puzzles.forEach(puzzle => {
    html += `
      <div class="puzzle-winner-item">
        <span class="puzzle-name">${puzzle}</span>
        <span class="puzzle-streak">Coming soon!</span>
      </div>
    `;
  });
  
  streaksContainer.innerHTML = html;
}

    function setupHistoryEventListeners() {
  const historyToggle = document.getElementById('historyToggle');
  const historyModal = document.getElementById('historyModal');
  const historyCloseBtn = document.getElementById('historyCloseBtn');

  historyToggle.addEventListener('click', () => {
    historyModal.style.display = 'block';
    isHistoryVisible = true;
    document.body.style.overflow = 'hidden';
    loadHistoryData();
  });

  function closeHistory() {
    historyModal.style.display = 'none';
    isHistoryVisible = false;
    document.body.style.overflow = '';
  }

  historyCloseBtn.addEventListener('click', closeHistory);
  historyModal.addEventListener('click', (e) => { if (e.target === historyModal) closeHistory(); });
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isHistoryVisible) closeHistory(); });
}

    async function loadResults() {
      if (!shouldRenderTable()) return;
      try {
        Object.keys(results).forEach(key => delete results[key]);
        Object.keys(cellMap).forEach(key => delete cellMap[key]);
        const { data, error } = await supabase.from("results").select("*").eq("date", today).neq("raw_result", "").order("created_at", { ascending: true });
        if (error) console.error("Error loading Supabase results:", error.message);
        puzzles.forEach(puzzle => { results[puzzle] = { Adam: "", Jonathan: "" }; });
        if (data && data.length > 0) {
          for (const entry of data) {
            const { puzzle_name, player, raw_result } = entry;
            if (results[puzzle_name] && (player === "Adam" || player === "Jonathan") && raw_result && raw_result.trim()) {
              results[puzzle_name][player] = raw_result;
            }
          }
        }
        renderTable();
      } catch (error) {
        console.error("Supabase connection failed:", error);
        puzzles.forEach(puzzle => { results[puzzle] = { Adam: "", Jonathan: "" }; });
        renderTable();
      }
    }

    function parseTime(t) { const [min, sec] = t.split(":").map(Number); return min * 60 + sec; }
    function markWinner(cell) { cell.classList.add("winner"); }
    function markBothAs(cls, a, b) { a.classList.add(cls); b.classList.add(cls); }

    function highlightWinner(tr, puzzle) {
      const adamCell = tr.children[1];
      const jonCell = tr.children[2];
      adamCell.classList.remove("winner", "tie");
      jonCell.classList.remove("winner", "tie");
      const aVal = results[puzzle].Adam;
      const jVal = results[puzzle].Jonathan;
      if (!aVal || !jVal) return;

      if (puzzle === "Connections") {
        if (aVal === jVal) return markBothAs("tie", adamCell, jonCell);
        const aLines = aVal.split("\n");
        const jLines = jVal.split("\n");
        const aIndex = aLines.findIndex(line => line.includes("üü™üü™üü™üü™"));
        const jIndex = jLines.findIndex(line => line.includes("üü™üü™üü™üü™"));
        if (aIndex !== -1 && (jIndex === -1 || aIndex < jIndex)) markWinner(adamCell);
        else if (jIndex !== -1 && (aIndex === -1 || jIndex < aIndex)) markWinner(jonCell);
        else markBothAs("tie", adamCell, jonCell);
      }
      if (puzzle === "Strands") {
        const aHints = (aVal.match(/üí°/g) || []).length;
        const jHints = (jVal.match(/üí°/g) || []).length;
        const aTotal = aVal.split("\n").length;
        const jTotal = jVal.split("\n").length;
        if (aTotal < jTotal) markWinner(adamCell);
        else if (jTotal < aTotal) markWinner(jonCell);
        else if (aHints < jHints) markWinner(adamCell);
        else if (jHints < aHints) markWinner(jonCell);
        else {
          const aIndex = aVal.indexOf("üü°");
          const jIndex = jVal.indexOf("üü°");
          if (aIndex !== -1 && (jIndex === -1 || aIndex < jIndex)) markWinner(adamCell);
          else if (jIndex !== -1 && (aIndex === -1 || jIndex < aIndex)) markWinner(jonCell);
          else markBothAs("tie", adamCell, jonCell);
        }
      }
      if (puzzle === "Keyword") {
        const aGuesses = parseInt(aVal.match(/(\d+) guesses/)?.[1] || "999");
        const jGuesses = parseInt(jVal.match(/(\d+) guesses/)?.[1] || "999");
        if (aGuesses < jGuesses) markWinner(adamCell);
        else if (jGuesses < aGuesses) markWinner(jonCell);
        else {
          const aTime = parseTime(aVal.match(/(\d+:\d+)/)?.[1] || "99:99");
          const jTime = parseTime(jVal.match(/(\d+:\d+)/)?.[1] || "99:99");
          if (aTime < jTime) markWinner(adamCell);
          else if (jTime < aTime) markWinner(jonCell);
          else markBothAs("tie", adamCell, jonCell);
        }
      }
      if (puzzle === "Wordle") {
        const aScore = parseInt(aVal.match(/\b(\d)\/6/)?.[1] || "7");
        const jScore = parseInt(jVal.match(/\b(\d)\/6/)?.[1] || "7");
        if (aScore < jScore) markWinner(adamCell);
        else if (jScore < aScore) markWinner(jonCell);
        else markBothAs("tie", adamCell, jonCell);
      }
      if (puzzle === "On The Record") {
        const aScore = parseInt(aVal.match(/\b(\d{1,3})\b/)?.[1] || "0");
        const jScore = parseInt(jVal.match(/\b(\d{1,3})\b/)?.[1] || "0");
        if (aScore > jScore) markWinner(adamCell);
        else if (jScore > aScore) markWinner(jonCell);
        else markBothAs("tie", adamCell, jonCell);
      }
      if (puzzle === "Apple Mini" || puzzle === "NYT Mini") {
        let aMatch = aVal.match(/(\d{1,2})\s*m[^\d]*(\d{1,2})\s*s/i);
        let jMatch = jVal.match(/(\d{1,2})\s*m[^\d]*(\d{1,2})\s*s/i);
        if (!aMatch) aMatch = aVal.match(/(\d{1,2})\s*[:\s]\s*(\d{1,2})/);
        if (!jMatch) jMatch = jVal.match(/(\d{1,2})\s*[:\s]\s*(\d{1,2})/);
        const aSecs = aVal.match(/^(\d+)\s*s$/i);
        const jSecs = jVal.match(/^(\d+)\s*s$/i);
        const aTime = aMatch ? parseInt(aMatch[1]) * 60 + parseInt(aMatch[2]) : aSecs ? parseInt(aSecs[1]) : 9999;
        const jTime = jMatch ? parseInt(jMatch[1]) * 60 + parseInt(jMatch[2]) : jSecs ? parseInt(jSecs[1]) : 9999;
        if (aTime < jTime) markWinner(adamCell);
        else if (jTime < aTime) markWinner(jonCell);
        else markBothAs("tie", adamCell, jonCell);
      }
      if (puzzle === "Globle") {
        const aGuesses = parseInt(aVal.match(/=\s*(\d+)/)?.[1] || "999");
        const jGuesses = parseInt(jVal.match(/=\s*(\d+)/)?.[1] || "999");
        if (aGuesses < jGuesses) markWinner(adamCell);
        else if (jGuesses < aGuesses) markWinner(jonCell);
        else markBothAs("tie", adamCell, jonCell);
      }
      if (puzzle === "Flagle") {
        const aScore = aVal.includes("X") ? 7 : parseInt(aVal.match(/(\d)\/6/)?.[1] || "7");
        const jScore = jVal.includes("X") ? 7 : parseInt(jVal.match(/(\d)\/6/)?.[1] || "7");
        if (aScore < jScore) markWinner(adamCell);
        else if (jScore < aScore) markWinner(jonCell);
        else markBothAs("tie", adamCell, jonCell);
      }
      if (puzzle === "Tightrope") {
        const aChecks = (aVal.match(/‚úÖ/g) || []).length;
        const jChecks = (jVal.match(/‚úÖ/g) || []).length;
        if (aChecks > jChecks) markWinner(adamCell);
        else if (jChecks > aChecks) markWinner(jonCell);
        else {
          const aScore = parseInt(aVal.match(/My Score:\s*(\d+)/)?.[1] || "0");
          const jScore = parseInt(jVal.match(/My Score:\s*(\d+)/)?.[1] || "0");
          if (aScore > jScore) markWinner(adamCell);
          else if (jScore > aScore) markWinner(jonCell);
          else markBothAs("tie", adamCell, jonCell);
        }
      }
    }

    async function deleteResult(puzzle, user) {
      try {
        const { error } = await supabase.from("results").update({ raw_result: "" }).eq("date", today).eq("puzzle_name", puzzle).eq("player", user);
        if (error) {
          alert(`Cannot delete record: ${error.message}`);
          return false;
        }
        if (results[puzzle]) results[puzzle][user] = "";
        await loadResults();
        return true;
      } catch (error) {
        alert(`Network error during deletion: ${error.message}`);
        return false;
      }
    }

    function enableEdit(td, puzzle, user, oldVal) {
      td.innerHTML = "";
      const ta = document.createElement("textarea");
      ta.value = oldVal;
      const submitBtn = document.createElement("button");
      submitBtn.textContent = "Submit";
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.style.marginLeft = "5px";
      deleteBtn.style.backgroundColor = "#ff6b6b";
      deleteBtn.style.color = "white";

      submitBtn.onclick = async () => {
        const newVal = ta.value.trim();
        if (!newVal) {
          if (confirm(`Delete the existing ${puzzle} result for ${user}?`)) {
            submitBtn.disabled = true;
            submitBtn.textContent = "Deleting...";
            await deleteResult(puzzle, user);
          }
          return;
        }
        results[puzzle][user] = newVal;
        const { error } = await supabase.from("results").upsert({
          date: today, puzzle_name: puzzle, player: user, raw_result: newVal
        }, { onConflict: ["date", "puzzle_name", "player"] });
        if (error) {
          console.error("Submission failed:", error.message);
          alert("Submission failed. Try again.");
        } else {
          renderTable();
        }
      };

      deleteBtn.onclick = async () => {
        if (confirm(`Are you sure you want to permanently delete this ${puzzle} result for ${user}?`)) {
          deleteBtn.disabled = true;
          deleteBtn.textContent = "Deleting...";
          const success = await deleteResult(puzzle, user);
          if (!success) {
            deleteBtn.disabled = false;
            deleteBtn.textContent = "Delete";
          }
        }
      };

      td.appendChild(ta);
      td.appendChild(document.createElement("br"));
      td.appendChild(submitBtn);
      td.appendChild(deleteBtn);
    }

    function renderTable() {
      if (!shouldRenderTable()) {
        const tbody = document.getElementById("puzzleRows");
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 2em; color: #666;">Please select your name above to start</td></tr>';
        return;
      }

      const tbody = document.getElementById("puzzleRows");
      document.querySelectorAll("td").forEach(td => td.classList.remove("winner", "tie"));
      tbody.innerHTML = "";

      puzzles.forEach(puzzle => {
        if (!results[puzzle]) results[puzzle] = { Adam: "", Jonathan: "" };
        const tr = document.createElement("tr");
        tr.setAttribute("data-puzzle", puzzle);
        const tdPuzzle = document.createElement("td");
        tdPuzzle.textContent = puzzle;
        tr.appendChild(tdPuzzle);

        ["Adam", "Jonathan"].forEach(user => {
          const td = document.createElement("td");
          const result = results[puzzle][user];
          if (!cellMap[puzzle]) cellMap[puzzle] = {};
          cellMap[puzzle][user] = td;

          if (user === currentUser) {
            if (result) {
              td.innerHTML = `<div class="submitted">${result}</div>`;
              const editBtn = document.createElement("button");
              editBtn.textContent = "Edit";
              editBtn.onclick = () => enableEdit(td, puzzle, user, result);
              td.appendChild(editBtn);
            } else {
              const ta = document.createElement("textarea");
              ta.placeholder = "Paste result...";
              const btn = document.createElement("button");
              btn.textContent = "Submit";
              btn.onclick = async () => {
                const newVal = ta.value.trim();
                if (!newVal) {
                  if (confirm(`Delete any existing ${puzzle} result for ${user}?`)) {
                    await deleteResult(puzzle, user);
                  }
                  return;
                }
                results[puzzle][user] = newVal;
                const { error } = await supabase.from("results").upsert({
                  date: today, puzzle_name: puzzle, player: user, raw_result: newVal
                }, { onConflict: ["date", "puzzle_name", "player"] });
                if (error) {
                  console.error("Submission failed:", error.message);
                  alert("Submission failed. Try again.");
                } else {
                  renderTable();
                }
              };
              td.appendChild(ta);
              td.appendChild(btn);
            }
          } else {
            const div = document.createElement("div");
            div.className = "submitted";
            div.textContent = result;
            td.appendChild(div);
          }
          tr.appendChild(td);
        });

        tbody.appendChild(tr);
        highlightWinner(tr, puzzle);
      });
      updateScoreboard();
    }

    function subscribeToChanges() {
      try {
        supabase.channel("puzzle-results-realtime").on("postgres_changes", {
          event: "*", schema: "public", table: "results", filter: `date=eq.${today}`
        }, (payload) => {
          const puzzle = payload.new?.puzzle_name || payload.old?.puzzle_name;
          const player = payload.new?.player || payload.old?.player;
          if (!puzzle || !player) return;
          if (!results[puzzle]) results[puzzle] = { Adam: "", Jonathan: "" };
          if (payload.eventType === "DELETE") {
            results[puzzle][player] = "";
            renderTable();
          } else if (payload.eventType === "INSERT" || payload.eventType === "UPDATE") {
            results[puzzle][player] = payload.new.raw_result || "";
            renderTable();
          }
        }).subscribe();

        supabase.channel("chat-messages-realtime").on("postgres_changes", {
          event: "*", schema: "public", table: "chat_messages", filter: `date=eq.${today}`
        }, (payload) => {
          if (payload.eventType === "INSERT") {
            chatMessages.push(payload.new);
            renderChatMessages();
            // Only set unread flag if message is from other player and chat is closed
            if (payload.new.player !== currentUser && !isChatVisible) {
              hasUnreadMessages = true;
            }
            updateUnreadBadge();
          } else if (payload.eventType === "UPDATE") {
            const msgIndex = chatMessages.findIndex(m => m.id === payload.new.id);
            if (msgIndex !== -1) {
              chatMessages[msgIndex] = payload.new;
              renderChatMessages();
              updateUnreadBadge();
            }
          }
        }).subscribe();
      } catch (error) {
        console.error("Failed to subscribe to realtime changes:", error);
      }
    }

    function updateScoreboard() {
      let acb = 0, jbb = 0, tie = 0, remaining = 0;
      puzzles.forEach(puzzle => {
        const row = document.querySelector(`tr[data-puzzle="${puzzle}"]`);
        if (!row) return;
        const [aCell, jCell] = [row.children[1], row.children[2]];
        const aVal = results[puzzle]?.Adam || "";
        const jVal = results[puzzle]?.Jonathan || "";
        if (!aVal || !jVal) {
          remaining++;
          return;
        }
        const aIsWin = aCell.classList.contains("winner");
        const jIsWin = jCell.classList.contains("winner");
        const isTie = aCell.classList.contains("tie") && jCell.classList.contains("tie");
        if (aIsWin && !jIsWin) acb++;
        else if (jIsWin && !aIsWin) jbb++;
        else if (isTie) tie++;
      });

      document.getElementById("acbCount").textContent = acb;
      document.getElementById("jbbCount").textContent = jbb;
      document.getElementById("tieCount").textContent = tie;
      document.getElementById("remainingCount").textContent = remaining;

      const acbEl = document.getElementById("acbCount");
      const jbbEl = document.getElementById("jbbCount");
      const acbCrown = document.getElementById("acbCrown");
      const jbbCrown = document.getElementById("jbbCrown");

      acbEl.style.color = "";
      jbbEl.style.color = "";
      acbCrown.style.display = "none";
      jbbCrown.style.display = "none";

      const canAcbWin = acb + remaining > jbb;
      const canJbbWin = jbb + remaining > acb;

      if (acb > jbb && !canJbbWin) {
        acbEl.style.color = "green";
        jbbEl.style.color = "red";
        acbCrown.style.display = "block";
      } else if (jbb > acb && !canAcbWin) {
        jbbEl.style.color = "green";
        acbEl.style.color = "red";
        jbbCrown.style.display = "block";
      } else if (acb > jbb) {
        acbEl.style.color = "green";
        jbbEl.style.color = "red";
      } else if (jbb > acb) {
        jbbEl.style.color = "green";
        acbEl.style.color = "red";
      } else if (acb === jbb && acb > 0) {
        acbEl.style.color = "#c9a700";
        jbbEl.style.color = "#c9a700";
      }
    }

    function renderEmptyTable() {
      if (!shouldRenderTable()) {
        const tbody = document.getElementById("puzzleRows");
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 2em; color: #666;">Please select your name above to start</td></tr>';
        return;
      }
      puzzles.forEach(puzzle => { results[puzzle] = { Adam: "", Jonathan: "" }; });
      renderTable();
    }

    window.addEventListener("DOMContentLoaded", async () => {
      const overlay = document.getElementById("loadingOverlay");
      setupChatEventListeners();
      renderEmptyTable();
      showChatInterface();
      setupHistoryEventListeners(); // ADD THIS LINE
await loadLastReadFromSupabase(); // ADD THIS LINE
      try {
        const loadPromise = Promise.all([loadResults(), loadChatMessages()]);
        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Loading timeout')), 10000));
        await Promise.race([loadPromise, timeoutPromise]);
        subscribeToChanges();
      } catch (error) {
        console.error("Loading failed:", error);
        renderTable();
      } finally {
        overlay.style.display = "none";
      }
    });
  </script>
  <script>
  alert("Top-level JS is running");

  const supabase = supabase.createClient(
    "https://iqhgsdpqqshfeiqrkrqw.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  );

  window.addEventListener("DOMContentLoaded", () => {
    alert("DOMContentLoaded fired");
  });
</script>
</body>
</html>