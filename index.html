<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>I'm Puzzled</title>
  <style>
    /* I'm Puzzled v2025.05.31.1 - FIXED all 5 polish issues */
    
    :root {
      --purple: #6b46c1;
      --light-purple: #a855f7;
      --green: #059669;
      --red: #dc2626;
      --amber: #f59e0b;
      --gray: #64748b;
      --light-gray: #f1f5f9;
      --dark-gray: #334155;
    }
    
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding-top: 140px; /* ISSUE 3 FIX: Increased for crown space */
      padding-bottom: 80px;
      overflow-x: hidden;
    }
    
    /* ISSUE 3 FIX: Crown positioning and spacing */
    .top-strip {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      padding: 12px 20px 16px 20px; /* FIXED: Added bottom padding */
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      z-index: 1000;
      height: 140px; /* FIXED: Increased height for crown */
      display: flex;
      align-items: flex-start; /* FIXED: Align to top for better spacing */
      justify-content: space-between;
    }
    
    .scoreboard-container {
      padding-top: 20px; /* FIXED: Added padding for crown space */
    }
    
    .scoreboard-mini {
      display: flex;
      align-items: flex-start; /* FIXED: Align to top */
      gap: 25px;
      color: white;
      font-size: 0.95em;
      position: relative;
    }
    
    .score-item {
      text-align: center;
      position: relative;
      padding-top: 25px; /* FIXED: Space for crown */
    }
    
    .crown {
      position: absolute;
      top: -30px; /* ISSUE 3 FIX: Adjusted position to not clip */
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.8em;
      z-index: 10; /* FIXED: Ensure crown is visible */
      animation: bounce 2s infinite;
    }
    
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
      40% { transform: translateX(-50%) translateY(-10px); }
      60% { transform: translateX(-50%) translateY(-5px); }
    }
    
    .score-label {
      font-weight: 600;
      margin-bottom: 2px;
      font-size: 0.8em;
      opacity: 0.9;
    }
    
    .score-value {
      font-size: 1.4em;
      font-weight: 700;
    }
    
    .app-title {
      color: white;
      text-align: center;
      font-size: 1.1em;
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      margin: 0 20px;
      flex: 1;
      padding-top: 35px;
    }
    
    .tagline {
      font-size: 0.7em;
      opacity: 0.8;
      margin-top: 2px;
      font-style: italic;
    }
    
    .user-selector {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      color: white;
      font-size: 0.8em;
      padding-top: 35px;
    }
    
    .user-label {
      margin-bottom: 5px;
      opacity: 0.9;
      font-weight: 500;
    }
    
    #userSelect {
      padding: 6px 12px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      background: rgba(255,255,255,0.15);
      color: white;
      font-size: 0.9em;
      font-weight: 600;
      backdrop-filter: blur(10px);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    #userSelect:hover {
      background: rgba(255,255,255,0.25);
      border-color: rgba(255,255,255,0.5);
    }
    
    #userSelect:focus {
      outline: none;
      border-color: #f59e0b;
      box-shadow: 0 0 0 3px rgba(245,158,11,0.3);
    }
    
    #userSelect option {
      background: #4f46e5;
      color: white;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.1);
      backdrop-filter: blur(20px);
      overflow: hidden;
    }
    
    .date-header {
      background: linear-gradient(135deg, var(--purple) 0%, var(--light-purple) 100%);
      color: white;
      padding: 20px;
      text-align: center;
      font-size: 1.3em;
      font-weight: 700;
      margin: 0;
      text-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .table-container {
      padding: 0;
      overflow-x: auto;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
    }
    
    th {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      color: var(--dark-gray);
      padding: 16px 12px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
      border-bottom: 2px solid #e2e8f0;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    th:first-child {
      width: 200px;
      min-width: 200px;
    }
    
    th:not(:first-child) {
      width: 120px;
      min-width: 120px;
      text-align: center;
    }
    
    td {
      padding: 12px;
      border-bottom: 1px solid #f1f5f9;
      vertical-align: middle;
      transition: background-color 0.2s ease;
    }
    
    tr:hover td {
      background-color: #f8fafc;
    }
    
    .puzzle-name {
      font-weight: 600;
      color: var(--dark-gray);
      font-size: 0.95em;
    }
    
    .cell-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 40px;
    }
    
    .result-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.8em;
      font-weight: 600;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 60px;
      text-align: center;
    }
    
    .result-perfect {
      background: linear-gradient(135deg, var(--green) 0%, #10b981 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(5,150,105,0.3);
    }
    
    .result-close {
      background: linear-gradient(135deg, var(--amber) 0%, #fbbf24 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(245,158,11,0.3);
    }
    
    .result-struggled {
      background: linear-gradient(135deg, var(--red) 0%, #ef4444 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(220,38,38,0.3);
    }
    
    .result-badge:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .btn-edit, .btn-submit {
      background: none;
      border: 2px solid var(--purple);
      color: var(--purple);
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.7em;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    
    .btn-edit:hover, .btn-submit:hover {
      background: var(--purple);
      color: white;
      transform: translateY(-1px);
    }
    
    .btn-submit {
      border-color: var(--green);
      color: var(--green);
    }
    
    .btn-submit:hover {
      background: var(--green);
      color: white;
    }
    
    .hidden {
      display: none !important;
    }
    
    .bottom-strip {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
      z-index: 1000;
      cursor: pointer;
      transition: height 0.3s ease, transform 0.3s ease;
    }
    
    .bottom-strip.expanded {
      height: 70vh;
      cursor: default;
    }
    
    .strip-content {
      color: white;
      font-weight: 600;
      font-size: 0.9em;
      text-align: center;
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }
    
    .strip-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    .bottom-strip.expanded .strip-toggle {
      opacity: 0;
      pointer-events: none;
    }
    
    .chat-container {
      position: absolute;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 0;
      background: white;
      border-radius: 16px 16px 0 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
    }
    
    .bottom-strip.expanded .chat-container {
      opacity: 1;
      transform: translateY(0);
    }
    
    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #f1f5f9;
    }
    
    .chat-title {
      font-size: 1.2em;
      font-weight: 700;
      color: var(--purple);
    }
    
    .chat-close {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      color: var(--gray);
      padding: 5px;
      border-radius: 50%;
      transition: all 0.2s ease;
    }
    
    .chat-close:hover {
      background: #f1f5f9;
      color: var(--red);
    }
    
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 20px;
      padding: 10px;
      background: #f8fafc;
      border-radius: 12px;
      min-height: 200px;
    }
    
    .chat-message {
      margin-bottom: 16px;
    }
    
    .message-bubble {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: 18px;
      position: relative;
      word-wrap: break-word;
      line-height: 1.4;
    }
    
    .message-bubble.current-user {
      background: linear-gradient(135deg, var(--purple) 0%, var(--light-purple) 100%);
      color: white;
      margin-left: auto;
      border-bottom-right-radius: 6px;
    }
    
    .message-bubble.other-user {
      background: white;
      color: var(--dark-gray);
      border: 1px solid #e2e8f0;
      margin-right: auto;
      border-bottom-left-radius: 6px;
    }
    
    .chat-input-container {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }
    
    .chat-input {
      flex: 1;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      padding: 12px 16px;
      font-size: 0.9em;
      resize: vertical;
      min-height: 44px;
      max-height: 120px;
      font-family: inherit;
      transition: border-color 0.2s ease;
    }
    
    .chat-input:focus {
      outline: none;
      border-color: var(--purple);
      box-shadow: 0 0 0 3px rgba(107,70,193,0.1);
    }
    
    .chat-send-btn {
      background: linear-gradient(135deg, var(--purple) 0%, var(--light-purple) 100%);
      border: none;
      color: white;
      padding: 12px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 1.8em; /* ISSUE 5 FIX: Bigger emoji */
      min-width: 60px; /* ISSUE 5 FIX: Wider button */
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }
    
    .chat-send-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(107,70,193,0.3);
    }
    
    .chat-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    #unreadBadge {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #ef4444;
      color: white;
      border-radius: 50%;
      min-width: 20px;
      height: 20px;
      font-size: 0.7em;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid white;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    .version-info {
      position: fixed;
      bottom: 70px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7em;
      font-weight: 500;
      backdrop-filter: blur(10px);
      z-index: 999;
    }
    
    /* Pull to refresh styles */
    .pull-refresh {
      position: fixed;
      top: -60px;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      z-index: 1001;
      transition: transform 0.3s ease;
    }
    
    .pull-refresh.visible {
      transform: translateY(60px);
    }
    
    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    
    .loading-overlay.visible {
      display: flex;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #e2e8f0;
      border-top: 4px solid var(--purple);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Modal backdrop */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      backdrop-filter: blur(3px);
      padding: 20px;
    }
    
    .modal-backdrop.visible {
      display: flex;
    }
    
    .modal-content {
      background: white;
      border-radius: 16px;
      padding: 20px;
      max-width: 500px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #f1f5f9;
    }
    
    .modal-title {
      font-size: 1.2em;
      font-weight: 700;
      color: var(--purple);
    }
    
    .modal-close {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      color: var(--gray);
      padding: 5px;
      border-radius: 50%;
      transition: all 0.2s ease;
    }
    
    .modal-close:hover {
      background: #f1f5f9;
      color: var(--red);
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      body {
        padding-top: 120px;
        padding-bottom: 70px;
      }
      
      .top-strip {
        height: 120px;
        padding: 8px 15px 12px 15px;
      }
      
      .scoreboard-mini {
        gap: 15px;
        font-size: 0.85em;
      }
      
      .app-title {
        font-size: 1em;
        padding-top: 25px;
      }
      
      .user-selector {
        padding-top: 25px;
      }
      
      .container {
        margin: 0 10px;
        border-radius: 12px;
      }
      
      .table-container {
        overflow-x: auto;
      }
      
      th, td {
        padding: 8px 6px;
        font-size: 0.8em;
      }
      
      th:first-child {
        width: 150px;
        min-width: 150px;
      }
      
      th:not(:first-child) {
        width: 80px;
        min-width: 80px;
      }
      
      .result-badge {
        padding: 4px 8px;
        font-size: 0.7em;
        min-width: 50px;
      }
      
      .bottom-strip.expanded {
        height: 80vh;
      }
      
      .chat-container {
        padding: 15px;
      }
      
      .version-info {
        bottom: 80px;
        font-size: 0.6em;
      }
    }
  </style>
</head>
<body>
  <div id="pullRefresh" class="pull-refresh">↓ Release to refresh ↓</div>
  <div id="loadingOverlay" class="loading-overlay"><div class="loading-spinner"></div></div>
  
  <div class="top-strip">
    <div class="scoreboard-container">
      <div class="scoreboard-mini">
        <div id="adamScore" class="score-item">
          <div class="score-label">ACB</div>
          <div class="score-value">0</div>
        </div>
        <div id="jonathanScore" class="score-item">
          <div class="score-label">JBB</div>
          <div class="score-value">0</div>
        </div>
        <div id="tieScore" class="score-item">
          <div class="score-label">Tie</div>
          <div class="score-value">0</div>
        </div>
        <div id="leftScore" class="score-item">
          <div class="score-label">Left</div>
          <div class="score-value">10</div>
        </div>
      </div>
    </div>
    
    <div class="app-title">
      🧠 I'm Puzzled ‼️
      <div class="tagline">If you ain't first, you're last</div>
    </div>
    
    <div class="user-selector">
      <div class="user-label">Signed in as:</div>
      <select id="userSelect">
        <option value="">(choose)</option>
        <option value="Adam">Adam 🌵</option>
        <option value="Jonathan">Jonathan 💩</option>
      </select>
    </div>
  </div>

  <div class="container">
    <div class="date-header" id="dateHeader">2025-05-30 (Fri)</div>
    <div class="table-container">
      <table id="puzzleTable">
        <thead>
          <tr><th>Puzzle</th><th>Adam 🌵</th><th>Jonathan 💩</th></tr>
        </thead>
        <tbody id="puzzleTableBody">
          <tr><td class="puzzle-name">Connections</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">Strands</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">On the Record</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">Keyword</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">NYT Mini</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">Apple Mini</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">Globle</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">Flagle</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">Wordle</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
          <tr><td class="puzzle-name">Tightrope</td><td><div class="cell-content"></div></td><td><div class="cell-content"></div></td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="version-info">v2025.05.31.1 - Fixed All 5 Polish Issues! 🎯✅</div>

  <div id="bottomStrip" class="bottom-strip">
    <div class="strip-content">
      <div class="strip-toggle" id="chatToggle">
        🚮 <span>Trash Talk Central 🔥</span>
        <div id="unreadBadge" style="display: none;"></div>
      </div>
      <div class="chat-container">
        <div class="chat-header">
          <div class="chat-title">Trash Talk Central 🔥</div>
          <button class="chat-close" id="chatCloseBtn">×</button>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input-container">
          <textarea id="chatInput" class="chat-input" placeholder="Type your trash talk here..." rows="1"></textarea>
          <button id="chatSendBtn" class="chat-send-btn" disabled>🚮</button>
        </div>
      </div>
    </div>
  </div>

  <div id="historyModal" class="modal-backdrop">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Historical Results</div>
        <button class="modal-close" id="historyCloseBtn">×</button>
      </div>
      <div id="historyContent"></div>
    </div>
  </div>

  <div id="resultModal" class="modal-backdrop">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title" id="resultModalTitle">Select Result</div>
        <button class="modal-close" id="resultCloseBtn">×</button>
      </div>
      <div id="resultModalContent">
        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
          <button class="result-badge result-perfect" onclick="selectResult('perfect')">Perfect</button>
          <button class="result-badge result-close" onclick="selectResult('close')">Close</button>
          <button class="result-badge result-struggled" onclick="selectResult('struggled')">Struggled</button>
        </div>
        <div style="display: flex; gap: 10px;">
          <button onclick="selectResult('delete')" style="background: #ef4444; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Delete</button>
          <button onclick="closeResultModal()" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <div id="chatModal" class="modal-backdrop">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Trash Talk Central 🔥</div>
        <button class="modal-close" id="chatModalCloseBtn">×</button>
      </div>
      <div class="chat-messages" id="chatModalMessages" style="height: 300px; overflow-y: auto; margin-bottom: 20px; padding: 10px; background: #f8fafc; border-radius: 12px;"></div>
      <div class="chat-input-container">
        <textarea id="chatModalInput" class="chat-input" placeholder="Type your trash talk here..." rows="1"></textarea>
        <button id="chatModalSendBtn" class="chat-send-btn" disabled>🚮</button>
      </div>
    </div>
  </div>

  <script type="module">
    import userManager from './modules/core/user-management.js';
    import supabaseClient from './modules/core/supabase-client.js';
    import dateHelpers from './modules/utils/date-helpers.js';
    import puzzleTable from './modules/ui/puzzle-table.js';
    import scoreboard from './modules/ui/scoreboard.js';
    import chatSystem from './modules/ui/chat-system.js';
    import historyModal from './modules/ui/history-modal.js';
    import mainApp from './modules/app/main.js';

    let currentPuzzle = '';
    let currentUser = '';
    let isInitialized = false;
    let realtimeSubscription = null;
    let loadingTimeout = null;
    let pullRefreshActive = false;
    let startY = 0;
    let currentY = 0;
    let pulling = false;
    let lastFocusTime = Date.now();
    let connectionRetries = 0;
    let maxRetries = 3;
    let retryDelay = 2000;

    function showLoading(message = 'Loading...') {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) {
        overlay.classList.add('visible');
        if (loadingTimeout) clearTimeout(loadingTimeout);
        loadingTimeout = setTimeout(() => {
          hideLoading();
          console.warn('Loading timeout - auto-hiding overlay');
        }, 15000);
      }
    }

    function hideLoading() {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) overlay.classList.remove('visible');
      if (loadingTimeout) {
        clearTimeout(loadingTimeout);
        loadingTimeout = null;
      }
    }

    function createNotification(type, title, message, duration = 5000) {
      const colors = {
        error: { bg: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)', shadow: 'rgba(239, 68, 68, 0.3)' },
        success: { bg: 'linear-gradient(135deg, #10b981 0%, #059669 100%)', shadow: 'rgba(16, 185, 129, 0.3)' },
        warning: { bg: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', shadow: 'rgba(245, 158, 11, 0.3)' },
        info: { bg: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)', shadow: 'rgba(59, 130, 246, 0.3)' }
      };

      const existingNotifications = document.querySelectorAll('.app-notification');
      if (existingNotifications.length >= 3) {
        existingNotifications[0].remove();
      }

      const notificationDiv = document.createElement('div');
      notificationDiv.className = 'app-notification';
      const color = colors[type] || colors.info;
      
      notificationDiv.style.cssText = `
        position: fixed;
        top: ${20 + (existingNotifications.length * 80)}px;
        right: 20px;
        background: ${color.bg};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px ${color.shadow};
        z-index: 2001;
        max-width: 320px;
        word-wrap: break-word;
        font-weight: 500;
        animation: slideInRight 0.3s ease;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      `;
      
      notificationDiv.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 4px; font-size: 0.9em;">${title}</div>
        <div style="font-size: 0.8em; opacity: 0.9; line-height: 1.3;">${message}</div>
      `;
      
      notificationDiv.addEventListener('mouseenter', () => {
        notificationDiv.style.transform = 'scale(1.02) translateX(-2px)';
      });
      
      notificationDiv.addEventListener('mouseleave', () => {
        notificationDiv.style.transform = 'scale(1) translateX(0)';
      });
      
      document.body.appendChild(notificationDiv);
      
      const removeTimeout = setTimeout(() => {
        if (notificationDiv.parentElement) {
          notificationDiv.style.animation = 'slideOutRight 0.3s ease';
          setTimeout(() => notificationDiv.remove(), 300);
        }
      }, duration);
      
      notificationDiv.addEventListener('click', () => {
        clearTimeout(removeTimeout);
        notificationDiv.style.animation = 'slideOutRight 0.3s ease';
        setTimeout(() => notificationDiv.remove(), 300);
      });

      return notificationDiv;
    }

    function showError(message, details = '') {
      console.error('Error:', message, details);
      createNotification('error', 'Error', message, 8000);
    }

    function showSuccess(message) {
      createNotification('success', 'Success', message, 3000);
    }

    function showWarning(message) {
      createNotification('warning', 'Warning', message, 4000);
    }

    function showInfo(message) {
      createNotification('info', 'Info', message, 3000);
    }

    function toggleBottomStrip() {
      const strip = document.getElementById('bottomStrip');
      const isExpanded = strip.classList.contains('expanded');
      
      if (isExpanded) {
        strip.classList.remove('expanded');
        document.body.style.overflow = '';
        console.log('💬 Bottom strip collapsed');
      } else {
        strip.classList.add('expanded');
        document.body.style.overflow = 'hidden';
        console.log('💬 Bottom strip expanded');
        
        if (window.chatSystem && window.chatSystem.markAsRead) {
          setTimeout(() => {
            window.chatSystem.markAsRead();
            console.log('💬 Marked messages as read');
          }, 100);
        }
      }
    }

    const modalManager = {
      openModals: new Set(),
      
      open(modalId, data = {}) {
        const modal = document.getElementById(modalId);
        if (!modal) {
          console.error(`Modal ${modalId} not found`);
          return false;
        }
        
        modal.classList.add('visible');
        document.body.style.overflow = 'hidden';
        this.openModals.add(modalId);
        modal._modalData = data;
        
        console.log(`📱 Opened modal: ${modalId}`);
        return true;
      },
      
      close(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return false;
        
        modal.classList.remove('visible');
        this.openModals.delete(modalId);
        
        if (this.openModals.size === 0) {
          document.body.style.overflow = '';
        }
        
        if (modal._modalData) delete modal._modalData;
        console.log(`📱 Closed modal: ${modalId}`);
        return true;
      },
      
      closeAll() {
        this.openModals.forEach(modalId => this.close(modalId));
      },
      
      isOpen(modalId) {
        return this.openModals.has(modalId);
      }
    };

    window.openResultModal = (puzzle, user) => {
      currentPuzzle = puzzle;
      currentUser = user;
      
      const title = document.getElementById('resultModalTitle');
      if (title) title.textContent = `${puzzle} - ${user}`;
      
      modalManager.open('resultModal', { puzzle, user });
      console.log(`🎯 Opening result modal for ${puzzle} - ${user}`);
    };

    window.closeResultModal = () => {
      modalManager.close('resultModal');
      currentPuzzle = '';
      currentUser = '';
    };

    window.selectResult = async (result) => {
      if (!currentPuzzle || !currentUser) {
        showWarning('No puzzle or user selected');
        return;
      }
      
      showLoading(`Updating ${currentPuzzle}...`);
      
      try {
        if (result === 'delete') {
          await puzzleTable.deleteResult(currentPuzzle, currentUser);
          showSuccess(`Deleted ${currentPuzzle} result for ${currentUser}`);
        } else {
          await puzzleTable.updateResult(currentPuzzle, currentUser, result);
          showSuccess(`Updated ${currentPuzzle} to ${result} for ${currentUser}`);
        }
        
        await Promise.all([
          scoreboard.updateScores(),
          puzzleTable.loadData()
        ]);
        
        closeResultModal();
        
      } catch (error) {
        showError('Failed to update result', error.message);
        console.error('Error updating result:', error);
      } finally {
        hideLoading();
      }
    };

    window.openHistoryModal = async () => {
      showLoading('Loading history...');
      
      try {
        modalManager.open('historyModal');
        
        if (window.historyModal && window.historyModal.loadHistory) {
          await window.historyModal.loadHistory();
        }
        
        showSuccess('History loaded');
        
      } catch (error) {
        showError('Failed to load history', error.message);
        console.error('Error loading history:', error);
        modalManager.close('historyModal');
      } finally {
        hideLoading();
      }
    };

    window.closeHistoryModal = () => {
      modalManager.close('historyModal');
    };

    window.openChatModal = () => {
      modalManager.open('chatModal');
      const input = document.getElementById('chatModalInput');
      if (input) setTimeout(() => input.focus(), 100);
    };

    window.closeChatModal = () => {
      modalManager.close('chatModal');
    };

    window.navigateDate = async (direction) => {
      showLoading('Loading date...');
      
      try {
        const currentDate = dateHelpers.getCurrentDisplayDate();
        const newDate = direction === 'prev' 
          ? dateHelpers.getPreviousDay(currentDate)
          : dateHelpers.getNextDay(currentDate);
        
        const today = new Date();
        const maxDate = new Date(today.getTime() + (7 * 24 * 60 * 60 * 1000));
        
        if (newDate > maxDate) {
          showWarning('Cannot navigate too far into the future');
          return;
        }
        
        dateHelpers.setCurrentDate(newDate);
        
        const dateHeader = document.getElementById('dateHeader');
        if (dateHeader) {
          dateHeader.textContent = dateHelpers.formatDateHeader(newDate);
        }
        
        await Promise.all([
          puzzleTable.loadData(),
          scoreboard.updateScores(),
          chatSystem.loadMessages()
        ]);
        
        showSuccess(`Loaded ${dateHelpers.formatDateHeader(newDate)}`);
        
      } catch (error) {
        showError('Failed to navigate date', error.message);
        console.error('Error navigating date:', error);
      } finally {
        hideLoading();
      }
    };

    function setupPullToRefresh() {
      const pullRefresh = document.getElementById('pullRefresh');
      if (!pullRefresh) return;

      document.addEventListener('touchstart', (e) => {
        if (window.scrollY === 0 && !modalManager.openModals.size && !pullRefreshActive) {
          startY = e.touches[0].clientY;
          pulling = true;
        }
      }, { passive: true });

      document.addEventListener('touchmove', (e) => {
        if (!pulling || modalManager.openModals.size) return;
        
        currentY = e.touches[0].clientY;
        const pullDistance = currentY - startY;
        
        if (pullDistance > 0) {
          e.preventDefault();
          
          const threshold = 100;
          const maxDistance = 150;
          const normalizedDistance = Math.min(pullDistance, maxDistance);
          
          if (pullDistance > threshold) {
            pullRefresh.classList.add('visible');
            pullRefresh.textContent = '↑ Release to refresh ↑';
            pullRefresh.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
          } else {
            pullRefresh.classList.add('visible');
            pullRefresh.textContent = '↓ Pull to refresh ↓';
            pullRefresh.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
          }
          
          const opacity = Math.min(normalizedDistance / 100, 1);
          pullRefresh.style.opacity = opacity;
        }
      }, { passive: false });

      document.addEventListener('touchend', async (e) => {
        if (!pulling) return;
        
        const pullDistance = currentY - startY;
        const threshold = 100;
        
        if (pullDistance > threshold && !pullRefreshActive) {
          pullRefreshActive = true;
          pullRefresh.textContent = '🔄 Refreshing...';
          pullRefresh.style.background = 'linear-gradient(135deg, #6366f1 0%, #4f46e5 100%)';
          
          try {
            await Promise.all([
              puzzleTable.loadData(),
              scoreboard.updateScores(),
              chatSystem.loadMessages()
            ]);
            
            if (window.supabaseClient && window.supabaseClient.setupRealtimeSubscription) {
              await setupRealtimeSubscription();
            }
            
            showSuccess('Data refreshed successfully');
            
          } catch (error) {
            showError('Failed to refresh data', error.message);
            console.error('Refresh error:', error);
          } finally {
            setTimeout(() => {
              pullRefresh.classList.remove('visible');
              pullRefreshActive = false;
            }, 1000);
          }
        } else {
          pullRefresh.classList.remove('visible');
        }
        
        pulling = false;
        startY = 0;
        currentY = 0;
      }, { passive: true });
    }

    async function setupRealtimeSubscription() {
      if (!window.supabaseClient) return;
      
      try {
        if (realtimeSubscription) {
          await window.supabaseClient.removeRealtimeSubscription(realtimeSubscription);
          realtimeSubscription = null;
        }
        
        realtimeSubscription = await window.supabaseClient.setupRealtimeSubscription((payload) => {
          console.log('📡 Realtime update received:', payload);
          
          if (payload.table === 'puzzle_results') {
            if (window.puzzleTable && window.puzzleTable.handleRealtimeUpdate) {
              window.puzzleTable.handleRealtimeUpdate(payload);
            }
            if (window.scoreboard && window.scoreboard.handleRealtimeUpdate) {
              window.scoreboard.handleRealtimeUpdate(payload);
            }
          } else if (payload.table === 'chat_messages') {
            if (window.chatSystem && window.chatSystem.handleRealtimeUpdate) {
              window.chatSystem.handleRealtimeUpdate(payload);
            }
          }
          
          if (payload.eventType === 'INSERT' && payload.table === 'puzzle_results') {
            const data = payload.new;
            if (data.player !== userManager.getCurrentUser()) {
              showInfo(`${data.player} updated ${data.puzzle}`);
            }
          }
        });
        
        if (realtimeSubscription) {
          console.log('📡 Realtime subscription established');
          connectionRetries = 0;
        }
        
      } catch (error) {
        console.error('Failed to setup realtime subscription:', error);
        if (connectionRetries < maxRetries) {
          connectionRetries++;
          console.log(`🔄 Retrying realtime connection (${connectionRetries}/${maxRetries})`);
          setTimeout(() => setupRealtimeSubscription(), retryDelay * connectionRetries);
        } else {
          showWarning('Live updates unavailable');
        }
      }
    }

    async function initializeApp() {
      if (isInitialized) {
        console.log('App already initialized');
        return;
      }
      
      console.log('🚀 I\'m Puzzled starting up v2025.05.31.1');
      showLoading('Initializing app...');
      
      try {
        console.log('📦 Initializing core modules...');
        
        await supabaseClient.init();
        console.log('✅ Supabase client initialized');
        
        userManager.setupUserSelector();
        console.log('✅ User manager initialized');
        
        userManager.onUserChanged = async (newUser, oldUser) => {
          console.log(`👤 User changed: ${oldUser} → ${newUser}`);
          showLoading(`Switching to ${newUser}...`);
          
          try {
            await Promise.all([
              puzzleTable.init(userManager, supabaseClient, dateHelpers),
              scoreboard.init(userManager, supabaseClient, dateHelpers),
              chatSystem.init(userManager, supabaseClient, dateHelpers),
              historyModal.init(userManager, supabaseClient, dateHelpers)
            ]);
            
            await Promise.all([
              puzzleTable.loadData(),
              scoreboard.updateScores(),
              chatSystem.loadMessages()
            ]);
            
            await setupRealtimeSubscription();
            showSuccess(`Switched to ${newUser}`);
            
          } catch (error) {
            showError('Failed to switch user', error.message);
            console.error('User switch error:', error);
          } finally {
            hideLoading();
          }
        };
        
        console.log('🎨 Initializing UI modules...');
        await Promise.all([
          puzzleTable.init(userManager, supabaseClient, dateHelpers),
          scoreboard.init(userManager, supabaseClient, dateHelpers),
          chatSystem.init(userManager, supabaseClient, dateHelpers),
          historyModal.init(userManager, supabaseClient, dateHelpers)
        ]);
        console.log('✅ UI modules initialized');
        
        console.log('📊 Loading initial data...');
        const today = dateHelpers.getToday();
        const dateHeader = document.getElementById('dateHeader');
        if (dateHeader) {
          dateHeader.textContent = dateHelpers.formatDateHeader(today);
        }
        
        await Promise.all([
          puzzleTable.loadData(),
          scoreboard.updateScores(),
          chatSystem.loadMessages()
        ]);
        console.log('✅ Initial data loaded');
        
        await setupRealtimeSubscription();
        
        window.userManager = userManager;
        window.supabaseClient = supabaseClient;
        window.dateHelpers = dateHelpers;
        window.puzzleTable = puzzleTable;
        window.scoreboard = scoreboard;
        window.chatSystem = chatSystem;
        window.historyModal = historyModal;
        window.modalManager = modalManager;
        
        isInitialized = true;
        console.log('🎯 I\'m Puzzled v2025.05.31.1 - Fully initialized and ready!');
        showSuccess('App initialized successfully');
        
      } catch (error) {
        console.error('💥 App initialization failed:', error);
        showError('Failed to initialize app', error.message);
      } finally {
        hideLoading();
      }
    }

    function setupEventListeners() {
      console.log('🎧 Setting up event listeners...');
      
      const chatToggle = document.getElementById('chatToggle');
      const chatCloseBtn = document.getElementById('chatCloseBtn');
      
      if (chatToggle) {
        chatToggle.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleBottomStrip();
        });
      }
      
      if (chatCloseBtn) {
        chatCloseBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleBottomStrip();
        });
      }

      const modals = ['resultModal', 'historyModal', 'chatModal'];
      modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
          modal.addEventListener('click', (e) => {
            if (e.target.id === modalId) {
              modalManager.close(modalId);
            }
          });
        }
      });

      const closeButtons = [
        { id: 'resultCloseBtn', action: () => closeResultModal() },
        { id: 'historyCloseBtn', action: () => closeHistoryModal() },
        { id: 'chatModalCloseBtn', action: () => closeChatModal() }
      ];
      
      closeButtons.forEach(({ id, action }) => {
        const btn = document.getElementById(id);
        if (btn) btn.addEventListener('click', action);
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          modalManager.closeAll();
          const bottomStrip = document.getElementById('bottomStrip');
          if (bottomStrip && bottomStrip.classList.contains('expanded')) {
            toggleBottomStrip();
          }
        }
        
        if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
          e.preventDefault();
          location.reload();
        }
        
        if ((e.ctrlKey || e.metaKey) && e.key === 'h') {
          e.preventDefault();
          openHistoryModal();
        }
      });

      window.addEventListener('focus', async () => {
        const timeSinceFocus = Date.now() - lastFocusTime;
        
        if (timeSinceFocus > 5 * 60 * 1000 && isInitialized) {
          console.log('🔄 Refreshing data after long absence');
          
          try {
            await Promise.all([
              puzzleTable.loadData(),
              scoreboard.updateScores(),
              chatSystem.loadMessages()
            ]);
            
            console.log('✅ Data refreshed after focus');
            
          } catch (error) {
            console.error('Failed to refresh data on focus:', error);
          }
        }
        
        lastFocusTime = Date.now();
      });

      window.addEventListener('blur', () => {
        lastFocusTime = Date.now();
      });

      window.addEventListener('online', async () => {
        console.log('🌐 Connection restored');
        showSuccess('Connection restored');
        
        if (isInitialized) {
          try {
            await setupRealtimeSubscription();
            await Promise.all([
              puzzleTable.loadData(),
              scoreboard.updateScores(),
              chatSystem.loadMessages()
            ]);
          } catch (error) {
            console.error('Failed to refresh after reconnection:', error);
          }
        }
      });

      window.addEventListener('offline', () => {
        console.log('📴 Connection lost');
        showError('Connection lost - some features may not work');
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.target.tagName === 'SELECT') {
          e.preventDefault();
        }
      });

      document.addEventListener('input', (e) => {
        if (e.target.tagName === 'TEXTAREA') {
          e.target.style.height = 'auto';
          e.target.style.height = Math.min(e.target.scrollHeight, 120) + 'px';
        }
      });

      console.log('🎧 Event listeners setup complete');
    }

    window.addEventListener('beforeunload', async () => {
      try {
        if (realtimeSubscription) {
          await supabaseClient.removeRealtimeSubscription(realtimeSubscription);
        }
      } catch (error) {
        console.error('Cleanup error:', error);
      }
    });

    const performanceObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.duration > 100) {
          console.warn(`⚠️ Slow operation detected: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
        }
      }
    });

    try {
      performanceObserver.observe({ entryTypes: ['measure', 'navigation'] });
    } catch (error) {
      console.log('Performance observer not supported');
    }

    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideInRight {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      
      @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
      
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
      
      .loading-pulse {
        animation: pulse 1.5s ease-in-out infinite;
      }
      
      .app-notification {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
    `;
    document.head.appendChild(style);

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setupEventListeners();
        setupPullToRefresh();
        initializeApp();
      });
    } else {
      setupEventListeners();
      setupPullToRefresh();
      initializeApp();
    }

    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      window.debugPuzzled = {
        userManager,
        supabaseClient,
        dateHelpers,
        puzzleTable,
        scoreboard,
        chatSystem,
        historyModal,
        modalManager,
        showLoading,
        hideLoading,
        showError,
        showSuccess,
        showWarning,
        showInfo,
        toggleBottomStrip,
        setupRealtimeSubscription,
        initializeApp,
        realtimeSubscription,
        isInitialized,
        version: 'v2025.05.31.1',
        async refreshAll() {
          await Promise.all([
            puzzleTable.loadData(),
            scoreboard.updateScores(),
            chatSystem.loadMessages()
          ]);
        },
        async resetApp() {
          isInitialized = false;
          await initializeApp();
        },
        getStatus() {
          return {
            initialized: isInitialized,
            currentUser: userManager.getCurrentUser(),
            hasRealtimeSubscription: !!realtimeSubscription,
            chatStatus: chatSystem.getChatStatus(),
            openModals: Array.from(modalManager.openModals),
            connectionRetries,
            version: 'v2025.05.31.1'
          };
        },
        async testNotifications() {
          showSuccess('Test success notification');
          setTimeout(() => showError('Test error notification'), 1000);
          setTimeout(() => showWarning('Test warning notification'), 2000);
          setTimeout(() => showInfo('Test info notification'), 3000);
        }
      };
      console.log('🔧 Debug functions available at window.debugPuzzled');
    }

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(registration => {
            console.log('SW registered: ', registration);
          })
          .catch(registrationError => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }

    window.addEventListener('error', (event) => {
      console.error('Uncaught error:', event.error);
      showError('An unexpected error occurred', event.error?.message || 'Unknown error');
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
      showError('An unexpected error occurred', event.reason?.message || 'Promise rejection');
      event.preventDefault();
    });

    console.log('🎯 I\'m Puzzled v2025.05.31.1 - All 5 polish issues fixed!');
    console.log('✅ Issue 1: Unread badge disappearing fix');
    console.log('✅ Issue 2: User dropdown display fix'); 
    console.log('✅ Issue 3: Crown positioning fix');
    console.log('✅ Issue 4: Keyboard behavior fix');
    console.log('✅ Issue 5: Send button emoji size fix');
    console.log('🚀 App ready for use!');

  </script>

</body>
</html>