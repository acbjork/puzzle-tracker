
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üß† I‚Äôm Puzzled ‚ÄºÔ∏è</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: system-ui, sans-serif; margin: 1em; }
    h1, .subtitle { text-align: center; margin: 0; }
    .subtitle { font-size: 0.95em; color: #555; margin-top: 0.2em; }
    table { width: 100%; border-collapse: collapse; margin-top: 1em; }
    th, td { border: 1px solid #ccc; padding: 0.5em; vertical-align: top; text-align: center; }
    th:first-child, td:first-child { text-align: left; }
textarea {
  width: 95%;
  box-sizing: border-box;
}
.submitted {
  white-space: pre-wrap;
  background: #f3f3f3;
  padding: 0.25em 0.5em;
  line-height: 1.2;
  border-radius: 4px;
}
    .winner { background: #d6f5d6; }
    .tie { background: #fff9c4; }
    .version { text-align: right; font-size: 0.85em; color: #888; margin-top: 2em; }
  
.winner { background-color: #d6f5d6 !important; }
.tie { background-color: #fff9c4 !important; }
.note {
  font-size: 0.75em;
  margin-top: 0.25em;
}
#scoreboard {
  margin: 1em 0;
  display: flex;
  justify-content: space-around;
  font-family: monospace;
  font-size: 1.5em;
}
.scoreboard-label {
  font-weight: bold;
  text-align: center;
}
.scoreboard-value {
  display: block;
  font-size: 1.5em;
}
#loadingOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: white;
  color: #444;
  font-size: 1.5em;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
    
</style>
</head>
<body>
  <div id="loadingOverlay">Loading‚Ä¶</div>
  <h1>üß† I‚Äôm Puzzled ‚ÄºÔ∏è</h1>
  <div class="subtitle">If you ain‚Äôt first, you‚Äôre last</div>

  <label for="userSelect">Signed in as:
    <select id="userSelect">
      <option value="">(choose)</option>
      <option value="Adam">Adam üåµ</option>
      <option value="Jonathan">Jonathan üí©</option>
    </select>
  </label>

<div id="scoreboard">
  <div class="scoreboard-label">ACB<span id="acbCount" class="scoreboard-value">0</span></div>
  <div class="scoreboard-label">JBB<span id="jbbCount" class="scoreboard-value">0</span></div>
  <div class="scoreboard-label">Tie<span id="tieCount" class="scoreboard-value">0</span></div>
  <div class="scoreboard-label">Remaining<span id="remainingCount" class="scoreboard-value">10</span></div>
</div>


<table id="puzzleTable">
    <thead>
      <tr>
        <th>Puzzle</th>
        <th>Adam üåµ</th>
        <th>Jonathan üí©</th>
      </tr>
    </thead>
    <tbody id="puzzleRows">
      <tr data-puzzle="Connections">
  <td>Connections</td>
  <td data-cell="Connections-Adam"></td>
  <td data-cell="Connections-Jonathan"></td>
</tr>
<tr data-puzzle="Strands">
  <td>Strands</td>
  <td data-cell="Strands-Adam"></td>
  <td data-cell="Strands-Jonathan"></td>
</tr>
<tr data-puzzle="On The Record">
  <td>On The Record</td>
  <td data-cell="On The Record-Adam"></td>
  <td data-cell="On The Record-Jonathan"></td>
</tr>
<tr data-puzzle="Keyword">
  <td>Keyword</td>
  <td data-cell="Keyword-Adam"></td>
  <td data-cell="Keyword-Jonathan"></td>
</tr>
<tr data-puzzle="NYT Mini">
  <td>NYT Mini</td>
  <td data-cell="NYT Mini-Adam"></td>
  <td data-cell="NYT Mini-Jonathan"></td>
</tr>
<tr data-puzzle="Apple Mini">
  <td>Apple Mini</td>
  <td data-cell="Apple Mini-Adam"></td>
  <td data-cell="Apple Mini-Jonathan"></td>
</tr>
<tr data-puzzle="Globle">
  <td>Globle</td>
  <td data-cell="Globle-Adam"></td>
  <td data-cell="Globle-Jonathan"></td>
</tr>
<tr data-puzzle="Flagle">
  <td>Flagle</td>
  <td data-cell="Flagle-Adam"></td>
  <td data-cell="Flagle-Jonathan"></td>
</tr>
<tr data-puzzle="Wordle">
  <td>Wordle</td>
  <td data-cell="Wordle-Adam"></td>
  <td data-cell="Wordle-Jonathan"></td>
</tr>
<tr data-puzzle="Tightrope">
  <td>Tightrope</td>
  <td data-cell="Tightrope-Adam"></td>
  <td data-cell="Tightrope-Jonathan"></td>
</tr>
    </tbody>
  </table>

  <div class="version">v0.2.33</div>

<script type="module">
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

  const supabase = createClient(
    "https://iqhgsdpqqshfeiqrkrqw.supabase.co",
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlxaGdzZHBxcXNoZmVpcXJrcnF3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NjExMDAsImV4cCI6MjA2MzQzNzEwMH0.W3eH88RD9s3pmuVlA-H7VIfVWLq_ymtj22JLd2f9Cec"
  );

  const today = new Date().toISOString().slice(0, 10);
  const currentUser = localStorage.getItem("user") || "Adam";
  const otherUser = currentUser === "Adam" ? "Jonathan" : "Adam";
  const puzzles = ["Connections", "Strands", "On The Record", "Keyword", "NYT Mini", "Apple Mini", "Globle", "Flagle", "Wordle", "Tightrope"];
  const results = {};
  const cellMap = {};

  const userSelect = document.querySelector("#userSelect");
  if (userSelect) {
    userSelect.value = currentUser;
    userSelect.addEventListener("change", (e) => {
      localStorage.setItem("user", e.target.value);
window.location.href = window.location.href;
    });
  }

  window.addEventListener("beforeunload", () => {
    localStorage.setItem("puzzleResults", JSON.stringify(results));
  });

  async function loadResults() {
  const { data, error } = await supabase
    .from("results")
    .select("*")
    .eq("date", today);

  if (error) {
    console.error("Error loading Supabase results:", error.message);
    return;
  }

  for (const entry of data) {
    if (!results[entry.puzzle_name]) {
      results[entry.puzzle_name] = { Adam: "", Jonathan: "" };
    }
    results[entry.puzzle_name][entry.player] = entry.raw_result;
  }
}function highlightWinner(tr, puzzle) {
  const [adamCell, jonCell] = [tr.children[1], tr.children[2]];
  const aVal = results[puzzle].Adam;
  const jVal = results[puzzle].Jonathan;

  if (!aVal || !jVal) return;

  if (puzzle === "Connections") {
    if (aVal === jVal) return markBothAs("tie", adamCell, jonCell);
    const aLines = aVal.split("\n");
    const jLines = jVal.split("\n");
    const aIndex = aLines.findIndex(line => line.includes("üü™üü™üü™üü™"));
    const jIndex = jLines.findIndex(line => line.includes("üü™üü™üü™üü™"));
    if (aIndex !== -1 && (jIndex === -1 || aIndex < jIndex)) markWinner(adamCell);
    else if (jIndex !== -1 && (aIndex === -1 || jIndex < aIndex)) markWinner(jonCell);
    else markBothAs("tie", adamCell, jonCell);
  }

  if (puzzle === "Strands") {
    const aHints = (aVal.match(/üí°/g) || []).length;
    const jHints = (jVal.match(/üí°/g) || []).length;
    const aTotal = aVal.split("\n").length;
    const jTotal = jVal.split("\n").length;
    if (aTotal < jTotal) markWinner(adamCell);
    else if (jTotal < aTotal) markWinner(jonCell);
    else if (aHints < jHints) markWinner(adamCell);
    else if (jHints < aHints) markWinner(jonCell);
    else {
      const aIndex = aVal.indexOf("üü°");
      const jIndex = jVal.indexOf("üü°");
      if (aIndex !== -1 && (jIndex === -1 || aIndex < jIndex)) markWinner(adamCell);
      else if (jIndex !== -1 && (aIndex === -1 || jIndex < aIndex)) markWinner(jonCell);
      else markBothAs("tie", adamCell, jonCell);
    }
  }

  if (puzzle === "Keyword") {
    const aGuesses = parseInt(aVal.match(/(\d+) guesses/)?.[1] || "999");
    const jGuesses = parseInt(jVal.match(/(\d+) guesses/)?.[1] || "999");
    if (aGuesses < jGuesses) markWinner(adamCell);
    else if (jGuesses < aGuesses) markWinner(jonCell);
    else {
      const aTime = parseTime(aVal.match(/(\d+:\d+)/)?.[1] || "99:99");
      const jTime = parseTime(jVal.match(/(\d+:\d+)/)?.[1] || "99:99");
      if (aTime < jTime) markWinner(adamCell);
      else if (jTime < aTime) markWinner(jonCell);
      else markBothAs("tie", adamCell, jonCell);
    }
  }

  if (puzzle === "Wordle") {
    const aScore = parseInt(aVal.match(/\b(\d)\/6/)?.[1] || "7");
    const jScore = parseInt(jVal.match(/\b(\d)\/6/)?.[1] || "7");
    if (aScore < jScore) markWinner(adamCell);
    else if (jScore < aScore) markWinner(jonCell);
    else markBothAs("tie", adamCell, jonCell);
  }

  if (puzzle === "On The Record") {
    const aScore = parseInt(aVal.match(/\b(\d{1,3})\b/)?.[1] || "0");
    const jScore = parseInt(jVal.match(/\b(\d{1,3})\b/)?.[1] || "0");
    if (aScore > jScore) markWinner(adamCell);
    else if (jScore > aScore) markWinner(jonCell);
    else markBothAs("tie", adamCell, jonCell);
  }

  if (puzzle === "Apple Mini") {
    const aMatch = aVal.match(/(\d+)m\s*(\d+)s/);
    const jMatch = jVal.match(/(\d+)m\s*(\d+)s/);
    const aTime = aMatch ? parseInt(aMatch[1]) * 60 + parseInt(aMatch[2]) : 9999;
    const jTime = jMatch ? parseInt(jMatch[1]) * 60 + parseInt(jMatch[2]) : 9999;
    if (aTime < jTime) markWinner(adamCell);
    else if (jTime < aTime) markWinner(jonCell);
    else markBothAs("tie", adamCell, jonCell);
  }

  if (puzzle === "Globle") {
    const aGuesses = parseInt(aVal.match(/=\s*(\d+)/)?.[1] || "999");
    const jGuesses = parseInt(jVal.match(/=\s*(\d+)/)?.[1] || "999");
    if (aGuesses < jGuesses) markWinner(adamCell);
    else if (jGuesses < aGuesses) markWinner(jonCell);
    else markBothAs("tie", adamCell, jonCell);
  }

  if (puzzle === "Flagle") {
    const aScore = aVal.includes("X") ? 7 : parseInt(aVal.match(/\b(\d)/)?.[1] || "7");
    const jScore = jVal.includes("X") ? 7 : parseInt(jVal.match(/\b(\d)/)?.[1] || "7");
    if (aScore < jScore) markWinner(adamCell);
    else if (jScore < aScore) markWinner(jonCell);
    else markBothAs("tie", adamCell, jonCell);
  }

  if (puzzle === "Tightrope") {
    const aChecks = (aVal.match(/‚úÖ/g) || []).length;
    const jChecks = (jVal.match(/‚úÖ/g) || []).length;
    if (aChecks > jChecks) markWinner(adamCell);
    else if (jChecks > aChecks) markWinner(jonCell);
    else {
      const aScore = parseInt(aVal.match(/My Score:\s*(\d+)/)?.[1] || "0");
      const jScore = parseInt(jVal.match(/My Score:\s*(\d+)/)?.[1] || "0");
      if (aScore > jScore) markWinner(adamCell);
      else if (jScore > aScore) markWinner(jonCell);
      else markBothAs("tie", adamCell, jonCell);
    }
  }
}

function parseTime(t) {
  const [min, sec] = t.split(":").map(Number);
  return min * 60 + sec;
}

function markWinner(cell) {
  cell.classList.add("winner");
}

function markBothAs(cls, a, b) {
  a.classList.add(cls);
  b.classList.add(cls);
}
function enableEdit(td, puzzle, user, oldVal) {
  td.innerHTML = "";
  const ta = document.createElement("textarea");
  ta.value = oldVal;
  const btn = document.createElement("button");
  btn.textContent = "Submit";
  btn.onclick = () => {
    results[puzzle][user] = ta.value.trim();
    renderTable();
  };
  td.appendChild(ta);
  td.appendChild(btn);
}
  function renderTable() {
    const tbody = document.getElementById("puzzleRows");
    tbody.innerHTML = "";

    puzzles.forEach(puzzle => {
      if (!results[puzzle]) results[puzzle] = { Adam: "", Jonathan: "" };

      const tr = document.createElement("tr");
      const tdPuzzle = document.createElement("td");
      tdPuzzle.textContent = puzzle;
      tr.appendChild(tdPuzzle);

      ["Adam", "Jonathan"].forEach(user => {
        const td = document.createElement("td");
        const result = results[puzzle][user];

        if (!cellMap[puzzle]) cellMap[puzzle] = {};
        cellMap[puzzle][user] = td;

        if (user === currentUser) {
          if (result) {
            const div = document.createElement("div");
            div.className = "submitted";
            div.textContent = result;
            td.appendChild(div);
            const editBtn = document.createElement("button");
            editBtn.textContent = "Edit";
            editBtn.onclick = () => enableEdit(td, puzzle, user, result);
            td.appendChild(editBtn);
          } else {
            const ta = document.createElement("textarea");
            ta.placeholder = "Paste result...";
            const btn = document.createElement("button");
            btn.textContent = "Submit";
            btn.onclick = () => {
              results[puzzle][user] = ta.value.trim();
              renderTable();
            };
            td.appendChild(ta);
            td.appendChild(btn);
          }
        } else {
          const div = document.createElement("div");
          div.className = "submitted";
          div.textContent = result;
          td.appendChild(div);
        }

        tr.appendChild(td);
      });

      highlightWinner(tr, puzzle);
      tbody.appendChild(tr);
    });

    document.getElementById("puzzleTable").style.display = "table";
    updateScoreboard();
  }

function renderTextInput(cell, puzzle, existingValue = "") {
  const textarea = document.createElement("textarea");
  textarea.placeholder = "Paste result...";
  textarea.style.width = "95%";
  textarea.value = existingValue;

  const button = document.createElement("button");
  button.innerText = "Submit";
  button.className = "submit-btn";

  button.addEventListener("click", async () => {
    const val = textarea.value.trim();
    if (!val) return;

    // 1. Update local results for faster UI feedback
    if (!results[puzzle]) results[puzzle] = { Adam: "", Jonathan: "" };
    results[puzzle][currentUser] = val;
    setTimeout(() => renderTable(), 0);

    // 2. Still sync to Supabase in background
    const { error } = await supabase
      .from("results")
      .upsert(
        {
          date: today,
          puzzle_name: puzzle,
          player: currentUser,
          raw_result: val,
        },
        { onConflict: ["date", "puzzle_name", "player"] }
      );

    if (error) {
      console.error("Submit failed:", error.message);
      alert("Submission failed. Try again.");
    } else {
      console.log("Submission succeeded.");
    }
  });

  cell.innerHTML = "";
  cell.appendChild(textarea);
  cell.appendChild(button);
}

  function subscribeToChanges() {
    supabase
      .channel("realtime:results")
      .on("postgres_changes", {
        event: "*",
        schema: "public",
        table: "results"
      }, (payload) => {
        if (payload.new?.date === today) {
          const cell = document.querySelector(`[data-cell="${payload.new.puzzle_name}-${payload.new.player}"]`);
          if (cell && payload.new.player !== currentUser) {
            cell.innerHTML = payload.new.raw_result;
          }
        }
      })
      .subscribe();
  }

  function updateScoreboard() {
    let acb = 0, jbb = 0, tie = 0, remaining = 0;
    puzzles.forEach(puzzle => {
      const aVal = results[puzzle]?.Adam || "";
      const jVal = results[puzzle]?.Jonathan || "";
      if (!aVal || !jVal) {
        remaining++;
        return;
      }
const row = document.querySelector(`tr[data-puzzle="${puzzle}"]`);
      const [aCell, jCell] = [row.children[1], row.children[2]];
      if (aCell.classList.contains("winner")) acb++;
      else if (jCell.classList.contains("winner")) jbb++;
      else if (aCell.classList.contains("tie")) tie++;
    });

    const acbEl = document.getElementById("acbCount");
    const jbbEl = document.getElementById("jbbCount");

    acbEl.textContent = acb;
    jbbEl.textContent = jbb;
    document.getElementById("tieCount").textContent = tie;
    document.getElementById("remainingCount").textContent = remaining;

    if (acb > jbb) {
      acbEl.style.color = "green";
      jbbEl.style.color = "red";
    } else if (jbb > acb) {
      jbbEl.style.color = "green";
      acbEl.style.color = "red";
    } else {
      acbEl.style.color = "#c9a700";
      jbbEl.style.color = "#c9a700";
    }
  }

  window.addEventListener("DOMContentLoaded", async () => {
  const overlay = document.getElementById("loadingOverlay");
  try {
    await loadResults();      // wait for Supabase
    renderTable();            // then build UI
    subscribeToChanges();     // and listen for live updates
  } finally {
    overlay.style.display = "none";  // hide "Loading‚Ä¶" no matter what
  }
});
  /*
    const saved = localStorage.getItem("puzzleResults");
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        for (const puzzle in parsed) {
          if (!results[puzzle]) results[puzzle] = { Adam: "", Jonathan: "" };
          results[puzzle].Adam = parsed[puzzle].Adam || "";
          results[puzzle].Jonathan = parsed[puzzle].Jonathan || "";
        }
      } catch (e) {
        console.error("Failed to load saved results:", e);
      }
    }
    */
</script>
</body>
</html>
