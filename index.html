<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üß† I'm Puzzled ‚ÄºÔ∏è</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Copy all the CSS from v0.5.1 and just add these v0.6.0 changes */
    body { font-family: system-ui, sans-serif; margin: 1em; }
    h1, .subtitle { text-align: center; margin: 0; }
    .subtitle { font-size: 0.95em; color: #555; margin-top: 0.2em; margin-bottom: 2em; }
    .user-select-area { margin-top: 1em; margin-bottom: 3em; }
    table { width: 100%; border-collapse: collapse; margin-top: 1em; }
    th, td { border: 1px solid #ccc; padding: 0.5em; vertical-align: top; text-align: center; }
    th:first-child, td:first-child { text-align: left; }
    textarea { width: 95%; box-sizing: border-box; }
    .submitted { white-space: pre-wrap; background: transparent; padding: 0.25em 0.5em; line-height: 1.2; border-radius: 4px; }
    .winner { background-color: #d6f5d6 !important; }
    .tie { background-color: #fff9c4 !important; }
    .version { text-align: right; font-size: 0.85em; color: #888; margin-top: 2em; }
    
    #scoreboard { margin: 1em 0; display: flex; justify-content: space-around; font-family: monospace; font-size: 1.5em; position: relative; }
    .scoreboard-label { font-weight: bold; text-align: center; position: relative; }
    .scoreboard-value { display: block; font-size: 1.5em; }
    .crown { position: absolute; top: -40px; left: 50%; transform: translateX(-50%); font-size: 2em; animation: crownBounce 1s ease-in-out infinite alternate; }
    @keyframes crownBounce { 0% { transform: translateX(-50%) translateY(0px); } 100% { transform: translateX(-50%) translateY(-5px); } }

    #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; color: #444; font-size: 1.5em; display: flex; align-items: center; justify-content: center; z-index: 9999; }

    .chat-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1000; display: none; backdrop-filter: blur(4px); }
    .chat-window { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 500px; height: 80%; max-height: 600px; background: white; border-radius: 12px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; overflow: hidden; }
    .chat-header { background: linear-gradient(135deg, #cc5500, #4a4a4a); color: white; padding: 1em; font-weight: bold; font-size: 1.1em; text-align: center; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); position: relative; }
    .chat-close-btn { position: absolute; top: 50%; right: 1em; transform: translateY(-50%); background: none; border: none; color: white; font-size: 1.5em; cursor: pointer; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; }
    .chat-close-btn:hover { background: rgba(255, 255, 255, 0.2); }
    .chat-messages { flex: 1; overflow-y: auto; padding: 1em; background: #f9f9f9; -webkit-overflow-scrolling: touch; }
    .chat-message { margin-bottom: 1em; display: flex; align-items: flex-start; animation: messageSlide 0.3s ease-out; position: relative; }
    @keyframes messageSlide { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    .chat-message.current-user { justify-content: flex-end; }
    .chat-message.other-user { justify-content: flex-start; }
    .message-bubble { max-width: 75%; padding: 0.75em 1em; border-radius: 18px; word-wrap: break-word; position: relative; cursor: pointer; transition: transform 0.1s; }
    .message-bubble:hover { transform: scale(1.02); }
    .message-bubble.current-user { background: #cc5500; color: white; border-bottom-right-radius: 4px; }
    .message-bubble.other-user { background: #e5e5e5; color: black; border-bottom-left-radius: 4px; }
    .message-bubble.deleted { background: #f0f0f0 !important; color: #888 !important; font-style: italic; opacity: 0.7; cursor: default; }
    .message-bubble.deleted:hover { transform: none; }
    .sender { font-weight: bold; font-size: 0.8em; margin-bottom: 0.25em; opacity: 0.8; }
    .message-text { font-size: 0.9em; line-height: 1.3; }
    .timestamp { font-size: 0.7em; opacity: 0.7; margin-top: 0.25em; }
    .chat-input-area { padding: 1em; background: white; border-top: 1px solid #ddd; display: flex; gap: 0.5em; align-items: flex-end; }
    
    /* v0.6.0 Orange styling changes */
    .chat-input { flex: 1; padding: 0.75em; border: 2px solid #ff6b35; border-radius: 20px; font-size: 0.9em; resize: none; min-height: 40px; max-height: 80px; outline: none; transition: border-color 0.2s; }
    .chat-input:focus { border-color: #ff6b35; }
    .chat-send-btn { background: linear-gradient(135deg, #ff6b35, #f7931e); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; cursor: pointer; font-size: 1.2em; transition: transform 0.2s, box-shadow 0.2s; display: flex; align-items: center; justify-content: center; }
    .chat-send-btn:hover { transform: scale(1.05); box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4); }
    
    .chat-send-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    .chat-empty { text-align: center; color: #888; font-style: italic; padding: 2em; }
    .unread-indicator { position: absolute; top: -5px; right: -5px; background: #ff4757; color: white; border-radius: 50%; min-width: 20px; height: 20px; font-size: 0.7em; display: flex; align-items: center; justify-content: center; font-weight: bold; animation: pulse 2s infinite; padding: 0 4px; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    .chat-toggle { position: relative; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 0.75em 1.5em; border-radius: 25px; cursor: pointer; font-weight: bold; margin: 1em 0; transition: all 0.3s; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
    .chat-toggle:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4); }
    .delete-confirmation { position: absolute; top: -40px; right: 0; background: #ff4757; color: white; padding: 0.5em; border-radius: 8px; font-size: 0.8em; white-space: nowrap; z-index: 10; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); }
    .delete-confirmation button { background: white; color: #ff4757; border: none; padding: 0.25em 0.5em; margin: 0 0.25em; border-radius: 4px; cursor: pointer; font-size: 0.8em; }

    @media (max-width: 768px) {
      body { margin: 0.5em; }
      table { font-size: 0.8em; }
      th:first-child, td:first-child { width: 25%; max-width: 80px; word-wrap: break-word; line-height: 1.2; }
      th:nth-child(2), th:nth-child(3), td:nth-child(2), td:nth-child(3) { width: 37.5%; }
      .submitted { font-size: 0.85em; line-height: 1.1; padding: 0.2em 0.4em; }
      #scoreboard { font-size: 1.2em; flex-wrap: wrap; gap: 0.5em; }
      .chat-window { width: 98%; height: 95%; max-width: none; }
      .chat-messages { padding: 0.75em; }
      .message-bubble { max-width: 85%; padding: 0.6em 0.8em; }
      textarea { width: 92%; }
    }

    @media (max-width: 480px) {
      h1 { font-size: 1.5em; }
      .subtitle { font-size: 0.85em; }
      th:first-child, td:first-child { width: 20%; max-width: 60px; font-size: 0.75em; }
      .submitted { font-size: 0.75em; }
      #scoreboard { font-size: 1em; }
      .scoreboard-value { font-size: 1.2em; }
      .chat-window { width: 100%; height: 100%; border-radius: 0; top: 0; left: 0; transform: none; }
    }
  </style>
</head>
<body>
  <div id="loadingOverlay">Loading‚Ä¶</div>
  <h1>üß† I'm Puzzled ‚ÄºÔ∏è</h1>
  <div class="subtitle">If you ain't first, you're last</div>

  <div class="user-select-area">
    <label for="userSelect">Signed in as:
      <select id="userSelect">
        <option value="">(choose)</option>
        <option value="Adam">Adam üåµ</option>
        <option value="Jonathan">Jonathan üí©</option>
      </select>
    </label>
  </div>

  <div id="scoreboard">
    <div class="scoreboard-label">ACB
      <span id="acbCrown" class="crown" style="display: none;">üëë</span>
      <span id="acbCount" class="scoreboard-value">0</span>
    </div>
    <div class="scoreboard-label">JBB
      <span id="jbbCrown" class="crown" style="display: none;">üëë</span>
      <span id="jbbCount" class="scoreboard-value">0</span>
    </div>
    <div class="scoreboard-label">Tie<span id="tieCount" class="scoreboard-value">0</span></div>
    <div class="scoreboard-label">Remaining<span id="remainingCount" class="scoreboard-value">10</span></div>
  </div>

  <button id="chatToggle" class="chat-toggle" style="display: none;">
    üí¨ Trash Talk Central üóëÔ∏è
    <span id="unreadBadge" class="unread-indicator" style="display: none;">0</span>
  </button>

  <div class="chat-modal" id="chatModal">
    <div class="chat-window">
      <div class="chat-header">
        üí¨ Trash Talk Central üóëÔ∏è
        <button class="chat-close-btn" id="chatCloseBtn">‚úï</button>
      </div>
      <div class="chat-messages" id="chatMessages">
        <div class="chat-empty">No trash talk yet... someone needs to start the smack down! üî•</div>
      </div>
      <div class="chat-input-area">
        <textarea id="chatInput" class="chat-input" placeholder="Drop some trash talk... üî•" maxlength="500" disabled></textarea>
        <button id="chatSendBtn" class="chat-send-btn" disabled>üöÆ</button>
      </div>
    </div>
  </div>

  <table id="puzzleTable">
    <thead>
      <tr><th>Puzzle</th><th>Adam üåµ</th><th>Jonathan üí©</th></tr>
    </thead>
    <tbody id="puzzleRows">
      <tr data-puzzle="Connections"><td>Connections</td><td data-cell="Connections-Adam"></td><td data-cell="Connections-Jonathan"></td></tr>
      <tr data-puzzle="Strands"><td>Strands</td><td data-cell="Strands-Adam"></td><td data-cell="Strands-Jonathan"></td></tr>
      <tr data-puzzle="On The Record"><td>On The Record</td><td data-cell="On The Record-Adam"></td><td data-cell="On The Record-Jonathan"></td></tr>
      <tr data-puzzle="Keyword"><td>Keyword</td><td data-cell="Keyword-Adam"></td><td data-cell="Keyword-Jonathan"></td></tr>
      <tr data-puzzle="NYT Mini"><td>NYT Mini</td><td data-cell="NYT Mini-Adam"></td><td data-cell="NYT Mini-Jonathan"></td></tr>
      <tr data-puzzle="Apple Mini"><td>Apple Mini</td><td data-cell="Apple Mini-Adam"></td><td data-cell="Apple Mini-Jonathan"></td></tr>
      <tr data-puzzle="Globle"><td>Globle</td><td data-cell="Globle-Adam"></td><td data-cell="Globle-Jonathan"></td></tr>
      <tr data-puzzle="Flagle"><td>Flagle</td><td data-cell="Flagle-Adam"></td><td data-cell="Flagle-Jonathan"></td></tr>
      <tr data-puzzle="Wordle"><td>Wordle</td><td data-cell="Wordle-Adam"></td><td data-cell="Wordle-Jonathan"></td></tr>
      <tr data-puzzle="Tightrope"><td>Tightrope</td><td data-cell="Tightrope-Adam"></td><td data-cell="Tightrope-Jonathan"></td></tr>
    </tbody>
  </table>

  <div class="version">v0.6.0 - Improved unread badges & better styling! üéØ</div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

    const supabase = createClient("https://iqhgsdpqqshfeiqrkrqw.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlxaGdzZHBxcXNoZmVpcXJrcnF3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NjExMDAsImV4cCI6MjA2MzQzNzEwMH0.W3eH88RD9s3pmuVlA-H7VIfVWLq_ymtj22JLd2f9Cec");

    const today = new Date().toISOString().slice(0, 10);
    let currentUser = '';
    try {
      const urlParams = new URLSearchParams(window.location.search);
      const urlUser = urlParams.get('user');
      const storedUser = localStorage.getItem('selectedUser');
      currentUser = urlUser || storedUser || "";
    } catch { currentUser = ""; }
    
    const puzzles = ["Connections", "Strands", "On The Record", "Keyword", "NYT Mini", "Apple Mini", "Globle", "Flagle", "Wordle", "Tightrope"];
    const results = {};
    const cellMap = {};
    let chatMessages = [];
    let isChatVisible = false;
    let lastReadMessageId = null;

    const userSelect = document.querySelector("#userSelect");
    if (userSelect) {
      userSelect.value = currentUser;
      userSelect.addEventListener("change", (e) => {
        const newUser = e.target.value;
        if (newUser) {
          localStorage.setItem('selectedUser', newUser);
          const url = new URL(window.location);
          url.searchParams.set('user', newUser);
          window.location.href = url.toString();
        }
      });
    }

    function shouldRenderTable() { return currentUser && (currentUser === "Adam" || currentUser === "Jonathan"); }

    function loadLastReadMessageId() {
      if (currentUser) {
        lastReadMessageId = localStorage.getItem(`lastReadMessageId_${currentUser}`);
      }
    }

    function saveLastReadMessageId(messageId) {
      if (currentUser && messageId) {
        lastReadMessageId = messageId;
        localStorage.setItem(`lastReadMessageId_${currentUser}`, messageId);
      }
    }

    async function loadChatMessages() {
      try {
        const { data, error } = await supabase.from("chat_messages").select("*").eq("date", today).order("created_at", { ascending: true });
        if (error) { console.error("Error loading chat messages:", error.message); return; }
        chatMessages = data || [];
        renderChatMessages();
        updateUnreadBadge();
      } catch (error) { console.error("Failed to load chat messages:", error); }
    }

    function renderChatMessages() {
      const container = document.getElementById('chatMessages');
      if (chatMessages.length === 0) {
        container.innerHTML = '<div class="chat-empty">No trash talk yet... someone needs to start the smack down! üî•</div>';
        return;
      }
      container.innerHTML = '';
      chatMessages.forEach(msg => {
        const messageDiv = document.createElement('div');
        const isCurrentUser = msg.player === currentUser;
        messageDiv.className = `chat-message ${isCurrentUser ? 'current-user' : 'other-user'}`;
        const senderEmoji = msg.player === 'Adam' ? 'üåµ' : 'üí©';
        const timestamp = new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = `message-bubble ${isCurrentUser ? 'current-user' : 'other-user'}`;
        if (msg.message === '[deleted]') {
          bubbleDiv.classList.add('deleted');
          bubbleDiv.innerHTML = `<div class="sender">${msg.player} ${senderEmoji}</div><div class="message-text">This message was deleted</div><div class="timestamp">${timestamp}</div>`;
        } else {
          bubbleDiv.innerHTML = `<div class="sender">${msg.player} ${senderEmoji}</div><div class="message-text">${escapeHtml(msg.message)}</div><div class="timestamp">${timestamp}</div>`;
          if (isCurrentUser) bubbleDiv.addEventListener('click', () => showDeleteConfirmation(bubbleDiv, msg.id));
        }
        messageDiv.appendChild(bubbleDiv);
        container.appendChild(messageDiv);
      });
      container.scrollTop = container.scrollHeight;
    }

    function showDeleteConfirmation(bubbleElement, messageId) {
      document.querySelectorAll('.delete-confirmation').forEach(el => el.remove());
      const confirmDiv = document.createElement('div');
      confirmDiv.className = 'delete-confirmation';
      confirmDiv.innerHTML = `Delete this message? <button onclick="deleteMessage('${messageId}')">Yes</button> <button onclick="this.parentElement.remove()">No</button>`;
      bubbleElement.style.position = 'relative';
      bubbleElement.appendChild(confirmDiv);
      setTimeout(() => { if (confirmDiv.parentElement) confirmDiv.remove(); }, 5000);
    }

    window.deleteMessage = async function(messageId) {
      try {
        const { error } = await supabase.from("chat_messages").update({ message: '[deleted]' }).eq("id", messageId);
        if (error) {
          console.error("Error deleting message:", error.message);
          alert("Failed to delete message. Try again.");
        } else {
          const msgIndex = chatMessages.findIndex(m => m.id === messageId);
          if (msgIndex !== -1) {
            chatMessages[msgIndex].message = '[deleted]';
            renderChatMessages();
          }
        }
      } catch (error) {
        console.error("Network error deleting message:", error);
        alert("Network error. Try again.");
      }
      document.querySelectorAll('.delete-confirmation').forEach(el => el.remove());
    };

    function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

    async function sendChatMessage() {
      const chatInput = document.getElementById('chatInput');
      const message = chatInput.value.trim();
      if (!message || !currentUser) return;
      const sendBtn = document.getElementById('chatSendBtn');
      sendBtn.disabled = true;
      sendBtn.textContent = '‚è≥';
      try {
        const { error } = await supabase.from("chat_messages").insert({ date: today, player: currentUser, message: message });
        if (error) {
          console.error("Error sending message:", error.message);
          alert("Failed to send message. Try again.");
        } else {
          chatInput.value = '';
        }
      } catch (error) {
        console.error("Network error sending message:", error);
        alert("Network error. Try again.");
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = 'üöÆ';
      }
    }

    function updateUnreadBadge() {
      const unreadBadge = document.getElementById('unreadBadge');
      
      if (isChatVisible || !currentUser || chatMessages.length === 0) {
        unreadBadge.style.display = 'none';
        return;
      }
      
      const unreadMessages = chatMessages.filter(msg => {
        if (msg.player === currentUser || msg.message === '[deleted]') return false;
        if (!lastReadMessageId) return true;
        
        const lastReadIndex = chatMessages.findIndex(m => m.id === lastReadMessageId);
        const currentIndex = chatMessages.findIndex(m => m.id === msg.id);
        
        return lastReadIndex === -1 || currentIndex > lastReadIndex;
      });
      
      if (unreadMessages.length > 0) {
        unreadBadge.textContent = unreadMessages.length;
        unreadBadge.style.display = 'flex';
      } else {
        unreadBadge.style.display = 'none';
      }
    }

    function markChatAsRead() {
      if (chatMessages.length > 0) {
        const otherPlayerMessages = chatMessages.filter(msg => 
          msg.player !== currentUser && msg.message !== '[deleted]'
        );
        if (otherPlayerMessages.length > 0) {
          const latestMessage = otherPlayerMessages[otherPlayerMessages.length - 1];
          saveLastReadMessageId(latestMessage.id);
        }
      }
      updateUnreadBadge();
    }

    function setupChatEventListeners() {
      const chatToggle = document.getElementById('chatToggle');
      const chatModal = document.getElementById('chatModal');
      const chatCloseBtn = document.getElementById('chatCloseBtn');
      const chatInput = document.getElementById('chatInput');
      const chatSendBtn = document.getElementById('chatSendBtn');

      chatToggle.addEventListener('click', () => {
        chatModal.style.display = 'block';
        isChatVisible = true;
        document.body.style.overflow = 'hidden';
        markChatAsRead();
        chatInput.focus();
      });

      function closeChat() {
        chatModal.style.display = 'none';
        isChatVisible = false;
        document.body.style.overflow = '';
        updateUnreadBadge();
      }

      chatCloseBtn.addEventListener('click', closeChat);
      chatModal.addEventListener('click', (e) => { if (e.target === chatModal) closeChat(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isChatVisible) closeChat(); });
      chatSendBtn.addEventListener('click', sendChatMessage);
      chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); } });
      chatInput.addEventListener('input', () => {
        const hasText = chatInput.value.trim().length > 0;
        chatSendBtn.disabled = !hasText || !currentUser;
      });
    }

    function showChatInterface() {
      if (shouldRenderTable()) {
        document.getElementById('chatToggle').style.display = 'block';
        document.getElementById('chatInput').disabled = false;
        document.getElementById('chatSendBtn').disabled = false;
      } else {
        document.getElementById('chatToggle').style.display = 'none';
        document.getElementById('chatModal').style.display = 'none';
        isChatVisible = false;
      }
    }

    // Copy all the puzzle logic from v0.5.1 (truncated for space - would include all loadResults, highlightWinner, etc)
    
    async function loadResults() {
      if (!shouldRenderTable()) return;
      try {
        Object.keys(results).forEach(key => delete results[key]);
        Object.keys(cellMap).forEach(key => delete cellMap[key]);
        const { data, error } = await supabase.from("results").select("*").eq("date", today).neq("raw_result", "").order("created_at", { ascending: true });
        if (error) console.error("Error loading Supabase results:", error.message);
        puzzles.forEach(puzzle => { results[puzzle] = { Adam: "", Jonathan: "" }; });
        if (data && data.length > 0) {
          for (const entry of data) {
            const { puzzle_name, player, raw_result } = entry;
            if (results[puzzle_name] && (player === "Adam" || player === "Jonathan") && raw_result && raw_result.trim()) {
              results[puzzle_name][player] = raw_result;
            }
          }
        }
        renderTable();
      } catch (error) {
        console.error("Supabase connection failed:", error);
        puzzles.forEach(puzzle => { results[puzzle] = { Adam: "", Jonathan: "" }; });
        renderTable();
      }
    }

    // Include all other functions from v0.5.1 here...
    // (renderTable, updateScoreboard, subscribeToChanges, etc.)

    window.addEventListener("DOMContentLoaded", async () => {
      const overlay = document.getElementById("loadingOverlay");
      loadLastReadMessageId();
      setupChatEventListeners();
      showChatInterface();
      try {
        const loadPromise = Promise.all([loadResults(), loadChatMessages()]);
        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Loading timeout')), 10000));
        await Promise.race([loadPromise, timeoutPromise]);
        // subscribeToChanges(); // Add realtime subscription
      } catch (error) {
        console.error("Loading failed:", error);
      } finally {
        overlay.style.display = "none";
      }
    });
  </script>
</body>
</html>